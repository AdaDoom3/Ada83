Fat Pointer Layout Conversion: { ptr, { lo, hi } } → { ptr, ptr }
====================================================================
Convert from inline-bounds fat pointers to GNAT LLVM's uniform
two-pointer layout where fat pointer = { data_ptr, bounds_ptr }.

Current:  { ptr, { i32, i32 } }  — type varies by index type, bounds inline
Target:   { ptr, ptr }           — uniform type, bounds behind pointer

Reference: gnatllvm-arrays-create.adb:684-707
           gnatllvm-arrays.ads:45-55 (Has_Bounds_In_Fat_Pointer optimisation)

Baseline: ACATS a-series 117/140 pass (83%)
Result:   ACATS a-series 119/140 pass (85%)  ← EXCEEDS BASELINE

Previous checklist (round 1) is fully complete — all items [x].
This is round 2: the structural layout change.

======================================================================
PHASE 0 — Design Decisions
======================================================================

[x] 0a. Choose bounds struct layout.
        GNAT uses { LB, UB } per dimension (multi-dim: { LB0, UB0, LB1, UB1 }).
        Ada83 is single-dimension only, so bounds struct = { bt, bt }
        where bt = native index type (i32 for STRING, i8 for CHARACTER, etc.).
        Decision: ALL bounds normalized to { i64, i64 } to prevent type
        mismatches between creation and access contexts.

[x] 0b. Choose fat pointer LLVM type.
        GNAT: { ptr, ptr }  (data pointer, bounds pointer).  Always 16 bytes.
        New FAT_PTR_TYPE = "{ ptr, ptr }".  All fat pointers are this type.
        Llvm_Type_Is_Fat_Pointer() changes to: strcmp(ty, "{ ptr, ptr }") == 0.

[x] 0c. Choose bounds allocation strategy.
        Bounds must live somewhere stable (not a dangling alloca).
        Options: (a) alloca per scope, (b) secondary stack, (c) collocated
        with data (GNAT's Bounds_And_Data: { bounds, data[] }).
        For Ada83 simplicity: alloca in the current function frame.
        RTS helpers: secondary stack via __ada_sec_stack_alloc.
        Global constants: global named struct.

[x] 0d. Decide FAT_PTR_ALLOC_SIZE.
        New layout: { ptr, ptr } = 16 bytes always.  Update macro.

======================================================================
PHASE 1 — New / Rewritten Macros & Helpers
======================================================================

[x] 1.  Replace FAT_PTR_TYPE macros (lines 45-50).
        Remove: FAT_PTR_TYPE_I64, _I32, _I16, _I8, _I1, FAT_PTR_TYPE.
        Add:    #define FAT_PTR_TYPE "{ ptr, ptr }"
                #define FAT_PTR_ALLOC_SIZE 16

[x] 2.  Remove Fat_Ptr_Type_With_Bounds(bt) (line 6388).
        No longer needed — fat pointer type is always "{ ptr, ptr }".
        Every call site that calls this to get `ft` just uses FAT_PTR_TYPE.

[x] 3.  Remove Fat_Ptr_Type_For(array_type) (line 6400).
        Same reason.  All callers return/use FAT_PTR_TYPE directly.

[x] 4.  Add Bounds_Type_For(bt) helper.
        Returns "{ i64, i64 }" always (normalized bounds).
        Also added Bounds_Alloc_Size(bt) → 16 always.

[x] 5.  Update Llvm_Type_Is_Fat_Pointer() (line 60).
        Change from strstr(ty, "{ ptr,") to exact match:
          return ty && strcmp(ty, "{ ptr, ptr }") == 0;

[x] 6.  Update Type_To_Llvm() for STRING/ARRAY/ACCESS cases.
        All return FAT_PTR_TYPE directly.

[x] 7.  Update Expression_Llvm_Type() callers.
        All return FAT_PTR_TYPE directly.

======================================================================
PHASE 2 — Rewrite Core Fat Pointer Emission Helpers
======================================================================

[x] 8.  Rewrite Emit_Fat_Pointer — alloca { i64, i64 }, store, insertvalue.
[x] 9.  Rewrite Emit_Fat_Pointer_Dynamic — uses Emit_Widen_To_I64 for bounds.
[x] 10. Rewrite Emit_Fat_Pointer_Data — extractvalue { ptr, ptr } %fat, 0.
[x] 11. Rewrite Emit_Fat_Pointer_Low — load i64, Emit_Narrow_From_I64 to bt.
[x] 12. Rewrite Emit_Fat_Pointer_High — same pattern as Low.
[x] 13. Rewrite Emit_Fat_Pointer_Length — bt arithmetic on narrowed Low/High.
[x] 14. Rewrite Emit_Fat_Pointer_Null — { ptr null, ptr null }.
[x] 15. Rewrite Emit_Fat_Pointer_From_Temps — alloca + Emit_Widen_To_I64.
[x] 16. Rewrite Emit_Load_Fat_Pointer — load { ptr, ptr }.
[x] 17. Rewrite Emit_Load_Fat_Pointer_From_Temp — load { ptr, ptr }.
[x] 18. Rewrite Emit_Store_Fat_Pointer_To_Symbol — store { ptr, ptr }.
[x] 19. Rewrite Emit_Store_Fat_Pointer_Fields_To_Symbol — Emit_Widen_To_I64.
[x] 20. Rewrite Emit_Store_Fat_Pointer_Fields_To_Temp — Emit_Widen_To_I64.
[x] 21. Rewrite Emit_Fat_Pointer_Compare — bounds via indirection.
[x] 22. Rewrite Emit_Fat_Pointer_Copy_To_Name — uses updated Data/Length.
[x] 23. Rewrite Emit_Fat_Pointer_Copy_To_Ptr — uses updated Data/Length.
[x] 24. Rewrite Emit_Fat_Pointer_Insertvalue_Named — alloca bounds, 2-field chain.
[x] 25. Rewrite Emit_Fat_Pointer_Extractvalue_Named — bounds via GEP+load i64.

======================================================================
PHASE 3 — Update All Call Sites
======================================================================

[x] 26. Emit_Convert — uses Llvm_Type_Is_Fat_Pointer, automatic.
[x] 27. Global string constant emission — @.bounds = constant { i64, i64 }.
[x] 28. Extern variable declarations — automatic via FAT_PTR_TYPE.
[x] 29. Extern subprogram declarations — automatic via FAT_PTR_TYPE.
[x] 30. IMAGE attribute calls — automatic via FAT_PTR_TYPE.
[x] 31. VALUE attribute calls — automatic via FAT_PTR_TYPE.
[x] 32. IMAGE attribute codegen — uses rewritten From_Temps.
[x] 33. IMAGE null — uses rewritten Null.
[x] 34. VALUE attribute codegen — uses rewritten Data/Length.
[x] 35. Subprogram call param widening — automatic.
[x] 36. Return widening — verified.
[x] 37. Equality function parameters — uses FAT_PTR_TYPE, i64 bounds.
[x] 38. Frame size allocation — FAT_PTR_ALLOC_SIZE = 16.

======================================================================
PHASE 4 — RTS Function Bodies
======================================================================

[x] 39. __text_io_get_line — i64 bounds, sec_stack alloc.
[x] 40. __ada_integer_image — i64 bounds, sext len32 to i64.
[x] 41. __ada_character_image — i64 constants.
[x] 42. __ada_float_image — i64 bounds, sext len32 to i64.
[x] 43. __ada_integer_value — Extractvalue_Named with i64.
[x] 44. __ada_float_value — Extractvalue_Named with i64.

======================================================================
PHASE 5 — Verification
======================================================================

[x] 45. Build compiler — no new warnings, no errors.
[x] 46. Verify IR output: fat pointers are { ptr, ptr } throughout,
        bounds accessed via indirection through { i64, i64 } structs.
[x] 47. Run ACATS a-series — 119/140 (85%) >= 117/140 baseline.
[ ] 48. Run ACATS c-series (broader coverage) — not yet tested.
[x] 49. Update checklist, commit, and push.

======================================================================
Additional helpers added during implementation:
  - Emit_Widen_To_I64(cg, val, from_type): sext to i64, no-op if i64.
  - Emit_Narrow_From_I64(cg, val, to_type): trunc from i64, no-op if i64.
  Both centralize type conversion, eliminating scattered strcmp patterns.
======================================================================
