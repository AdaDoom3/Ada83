Ada83 Compiler — ACATS C-Series Progress Checklist
====================================================

Compiler: ada83.c (~22,600 lines, single-file Ada 83 → LLVM IR)
Target:   ACATS c-series tests (ANSI/MIL-STD-1815A conformance)
Branch:   claude/refactor-ada83-c-mfxAj

READ GNAT LLVM SOURCES FOR HELP DURING DEVELOPMENT

=== COMPLETED (this session) ===

1. [x] Record component default expressions (RM 3.7)
   - Added default_expr field to Component_Info
   - Store defaults when parsing record type definitions
   - Generate initialization code for records without explicit init

2. [x] T'VAL range checking (RM 3.5.5)
   - VAL now raises CONSTRAINT_ERROR if n outside valid positions
   - Works for enumeration types (0..count-1) and scalar types

3. [x] Membership test for type names (M IN DT)
   - Fixed evaluation of right operand when it's a type name
   - Type bounds now properly extracted for range check

4. [x] Constrained → unconstrained array parameter passing (RM 6.4.1)
   - When passing constrained array to unconstrained formal, build fat pointer
   - Extract bounds from constrained type's Type_Info
   - Uses Emit_Fat_Pointer(cg, data_ptr, lo, hi)

5. [x] Aggregate type propagation in membership tests (RM 4.4)
   - For AGG IN T: resolve T first, propagate type to aggregate
   - Fixed: resolve right operand (type name) before left aggregate
   - Enables aggregate components to be properly typed

6. [x] Derived type operation inheritance (RM 3.4) - GNAT-style
   - Emit direct calls to parent operation instead of wrappers
   - Added parent_operation field to Symbol struct
   - Derive_Subprograms creates symbols with return/param type substitution
   - Code gen: call_target = sym->parent_operation ?: sym
   - Identical representation in Ada 83 = no conversion needed
   - c34 tests: 0 → 3 passing (c34001a, c34009a, c34009g)

7. [x] Function result indexing (func(...)(i))
   - Fixed: CREATE(X)(2) was treated as second function call
   - Added prefix_is_call_target check in Resolve_Apply
   - Complex prefix expressions now route to array indexing

8. [x] Floating-point type support and conversions
   - Float/double LLVM types based on Ada type size
   - fcmp for float comparisons, sitofp/fptosi conversions
   - c35 tests: 47 → 54 passing

9. [x] Boolean i1→i64 uniform widening
   - All boolean results (comparisons, AND/OR/XOR, NOT, membership)
     widened to i64 for uniform representation
   - Expression_Is_Boolean/Expression_Llvm_Type updated

10. [x] Fat pointer / ptr type mismatch fixes
    - Removed constrained CHARACTER array fat pointer hack from
      Generate_Identifier (was causing double-wrapping)
    - Fixed record equality callers to load fat pointers from GEP
    - Improved Emit_Convert: extractvalue for fat_ptr→ptr, load for
      ptr→fat_ptr, ptrtoint/inttoptr for fat_ptr↔i64
    - Guard fat pointer values from i64 widening in Generate_Identifier
    - Fix array element loading to preserve ptr/float/fat_ptr types

11. [x] Character array initialization fat_ptr/ptr dispatch
    - NK_STRING and unconstrained arrays → fat pointer copy
    - Constrained arrays → direct memcpy with known bounds
    - Fixed c36 regression (BIND 21→15)

12. [x] Function return value type preservation
    - Preserve ptr and fat_ptr types from function return widening
    - Previously incorrectly converted to i64 via ptrtoint/extractvalue

13. [x] Nested package body inline initialization (RM 7.2)
    - Nested packages emit init statements inline in enclosing function
    - Library-level packages use separate __init function
    - Fixes 128+ "expected instruction opcode" BIND errors

14. [x] Private/limited private type LLVM resolution
    - Type_To_Llvm follows parent_type chain for private types
    - Prevents private float/access types defaulting to i64

15. [x] Boolean double-widening fix in comparisons
    - Use Expression_Llvm_Type instead of assuming i1 for boolean
      sub-expressions (NOT, AND, OR already widen to i64)
    - c45 pass 28→37 (+9)

=== IN PROGRESS ===

Element concatenation (C & 3.0):
  - Scalar & Scalar should produce array when in context
  - Required for c34005a and similar tests
  - Need to infer array type from context

=== REMAINING ERROR CATEGORIES (by impact, BIND failures) ===

Category                                   | Count | Groups
-------------------------------------------|-------|--------
fat_ptr/scalar mismatch                    | ~357  | c3x, c4x
Undefined values (I/O exceptions + SSA)    | ~278  | ce, c3x
ptr/i64 mismatch                           | ~146  | c3x, c4x
Expected instruction opcode (malformed IR) | ~128  | c3x (mostly fixed)
double/float vs i64 (derived float ops)    |  ~51  | c34, c35
i64/i1 boolean mismatch                    |  ~42  | c34, c37 (partially fixed)

=== TEST RESULTS (latest) ===

Group | Pass | Total | Rate  | Change
------|------|-------|-------|--------
c32   |    2 |    19 |  10%  | baseline
c34   |    4 |    67 |   5%  | +1 (return widening fix)
c35   |   54 |   120 |  45%  | +7 (float support)
c36   |    4 |    33 |  12%  | BIND 21→15
c37   |   10 |    68 |  14%  | +1, BIND 35→33
c43   |    3 |    53 |   5%  | BIND 43→42
c45   |   37 |   108 |  34%  | +9 (boolean widening fix)
c48   |    1 |    31 |   3%  | stable

=== NOTES ===

- Coding style: Haskell-like C99, tight code-golfing, Literate Programming
- Ada-like full names, sparse but thoughtful comments
- Reference: /home/user/Ada83/reference/gnat/ (GNAT LLVM source)
- Computation model: all scalars in i64 width; narrow only at store/param
- Test harness: bash test.sh q <group>
