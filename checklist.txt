================================================================================
  Ada83 Compiler (ada83.c) — Comprehensive Function Audit Checklist
  23,734 lines | 17 sections | ~180+ functions
  Rating scale: A (excellent) B (good) C (fair) D (poor) F (needs rewrite)
================================================================================

LEGEND
  [GNAT]   Deviation from GNAT LLVM reference implementation
  [ADA]    Violation of Ada 83 RM semantics
  [DUP]    Duplicated code pattern (candidate for extraction)
  [OPT]    Suboptimal LLVM IR generation
  [LIMIT]  Hardcoded limit
  [PRED]   Missing GNAT sem_util.ads predicate equivalent

================================================================================
 S1. TYPE METRICS (lines 102-239)
================================================================================

Align_To (line ~102)
  Rating: A
  - Simple (x + align-1) & ~(align-1). Correct.

Llvm_Int_Type (line ~110)
  Rating: B
  - Maps bit widths to LLVM integer type strings
  - [OPT] Returns "i64" as default; could return exact width for 24/48-bit types

Llvm_Float_Type (line ~125)
  Rating: B
  - Maps 32->float, 64->double
  - [ADA] No support for LONG_LONG_FLOAT (80-bit x87)

Fits_In_Signed / Fits_In_Unsigned (lines ~135-155)
  Rating: A
  - Straightforward range checks

Bits_For_Range (line ~160)
  Rating: A
  - Correct ceil(log2) implementation

To_Bits (line ~180)
  Rating: B
  - Converts byte size to bits
  - [OPT] Trivial function, could be a macro

================================================================================
 S12. SEMANTIC ANALYSIS (lines ~7150-~12200, ~5000 lines)
================================================================================

Resolve_Expression (line ~7200)
  Rating: C
  - Large recursive resolution function
  - [ADA] Overload resolution is simplified — picks first match rather than
    doing full type-context-driven resolution (RM 8.6)
  - [GNAT] GNAT's Sem_Res is ~15,000 lines for expression resolution
  - [PRED] Missing: Is_Overloaded equivalent

Resolve_Binary_Op (line ~7500)
  Rating: C
  - [ADA] Mixed-mode arithmetic: integer * float should be illegal in Ada 83
    (RM 4.5.5) but may be silently accepted
  - [ADA] Fixed-point multiplication result type rules (RM 4.5.5) not
    fully implemented

Resolve_Unary_Op (line ~7700)
  Rating: B

Resolve_Apply (line ~7800)
  Rating: C
  - Function call / type conversion / array indexing resolution
  - [ADA] Ambiguity between function calls and array indexing not fully
    resolved by context
  - [DUP] Parameter counting/building pattern duplicated 5+ times

Resolve_Aggregate (line ~8200)
  Rating: C
  - [ADA] Named association with "others" choice: doesn't verify that
    all non-others choices are static (RM 4.3.3)
  - [DUP] Component matching duplicated between positional and named cases

Resolve_Declaration (line ~8500)
  Rating: C
  - Massive function handling all declaration kinds
  - [DUP] Generic formal installation code duplicated for:
    1. Subprogram bodies with generic formals
    2. Package bodies with generic formals
  - [ADA] Derived type operations: inherited operations should include
    all primitive operations of the parent (RM 3.4). Currently copies
    parent's exported subprograms but may miss some.
  - [PRED] Missing: Has_Private_Component, Is_Limited_Type,
    Has_Preelaborable_Initialization equivalents

Resolve_Statement (line ~9500)
  Rating: B
  - [ADA] CASE statement: doesn't verify completeness of alternatives
    (RM 5.4 requires all values covered)
  - [ADA] FOR loop: loop variable should be constant (RM 5.5)

Resolve_Type_Declaration (line ~10000)
  Rating: C
  - [ADA] Derived type: should freeze parent type (RM 13.14). Missing.
  - [GNAT] GNAT's Sem_Ch3 for type declarations is ~8000 lines

Resolve_Subprogram_Body (line ~10500)
  Rating: C
  - [DUP] Parameter type resolution duplicated from Resolve_Declaration
  - [ADA] Conformance checking between spec and body not implemented
    (RM 6.3.1). Major semantic gap.

Resolve_Generic_Instantiation (line ~11000)
  Rating: C
  - Three-pass formal resolution: type -> object -> subprogram
  - [ADA] Generic formal type matching rules (RM 12.3) are simplified
  - [DUP] Magic numbers 0-8 for generic type param def_kind duplicated;
    should be an enum
  - [GNAT] GNAT's Sem_Ch12 is ~12,000 lines

Install_Visible_Declarations / Install_Private_Declarations (lines ~11500-11800)
  Rating: C
  - [DUP] Nearly identical code for visible and private sections
  - [ADA] Private type completion rules (RM 7.3) are incomplete

SECTION 12 SUMMARY:
  Semantic analysis is the weakest section relative to GNAT.
  Key gaps: overload resolution, conformance checking, case completeness,
  derived type freezing, composite parameter passing.
  [DUP] ~500+ lines of duplicated patterns (parameter building, generic
  formal installation, declaration installation)
  Estimated savings: ~400 lines

================================================================================
 S13. CODE GENERATOR (lines ~12200-21700, ~9500 lines)
================================================================================

--- S13.1 Infrastructure (lines ~12200-12800) ---

Code_Generator_Init (line ~12210)
  Rating: B

Emit / Emit_Temp / Emit_Label (lines ~12250-12300)
  Rating: A — Clean LLVM IR emission helpers

Emit_Label_Here / Emit_Branch_If_Needed (lines ~12310-12340)
  Rating: A — Proper basic block management

Emit_Symbol_Name / Emit_Symbol_Ref (lines ~12350-12400)
  Rating: B
  - [OPT] String formatting on every emission; could cache mangled names

Emit_Convert (line ~12420)
  Rating: C
  - Handles sext/zext/trunc/bitcast between LLVM types
  - [OPT] strcmp-based type comparison is O(n); could use type enum
  - [ADA] Fixed-point <-> float conversion should scale by SMALL (RM 4.5.5)
    but Emit_Convert doesn't know about SMALL

Emit_Load / Emit_Store (lines ~12500-12550)
  Rating: B

Emit_Fat_Pointer_* (lines ~12600-12700)
  Rating: B
  - Fat pointer: { ptr, { i64, i64 } } for unconstrained arrays
  - [GNAT] GNAT LLVM uses thin pointers with bounds in dope vector.
    Fat pointer approach is valid but different.

--- S13.2 Expression Code Generation (lines ~12800-15500) ---

Generate_Integer_Literal (line ~12810)
  Rating: A

Generate_Real_Literal (line ~12840)
  Rating: B
  - Uses memcpy-based type punning for hex float constant emission
  - [OPT] Correct but could use LLVM's float literal format directly

Generate_String_Literal (line ~12900)
  Rating: B
  - Emits to string constant buffer, returns fat pointer
  - [OPT] Duplicate string deduplication not implemented

Generate_Identifier (line ~12980)
  Rating: C
  - [DUP] Uplevel access check pattern (owner != current_function) appears
    here and is duplicated in ~10 other places throughout codegen
  - [OPT] Named numbers (compile-time constants) are loaded from memory
    instead of being inlined as LLVM constants

Generate_Selected (line ~13200)
  Rating: C
  - Handles Pkg.Name, record.field, access.all
  - [DUP] Generic formal substitution loop duplicated here, in
    Generate_Attribute, Generate_Assignment, and Generate_For_Loop

Generate_Binary_Op (line ~13400)
  Rating: C
  - [ADA] Integer overflow on + - * should raise Constraint_Error (RM 4.5).
    No overflow check emitted.
  - [ADA] Division by zero should raise Constraint_Error. No check.
  - [OPT] All integer operations use i64 regardless of actual type width.
    This prevents LLVM from using narrower instructions.
  - [ADA] Fixed-point multiplication: (A*B)/SMALL not implemented
    correctly in all cases (RM 4.5.5)
  - [ADA] String concatenation (&) returns fat pointer — correct, but
    doesn't check that result bounds don't overflow

Generate_Unary_Op (line ~13800)
  Rating: B
  - Handles NOT, unary minus, ABS
  - [ADA] Unary minus overflow for Integer'First should raise CE

Generate_Apply (line ~13900)
  Rating: C
  - Function calls, type conversions, array indexing
  - [DUP] Parameter emission pattern is very long and contains duplicated
    logic for: IN params, OUT/IN OUT params, default values, frame pointers
  - [OPT] Array bounds check not emitted for indexing operations
  - [ADA] Type conversion range checks not emitted (RM 4.6)

Generate_Record_Field (line ~15400)
  Rating: B
  - GEP-based field access using byte offset
  - [OPT] Could use LLVM named struct types for better debug info

--- S13.3 Attribute Code Generation (lines ~15540-16900) ---

Type_Bound_Is_Compile_Time_Known (line 15543)
  Rating: B
  - Uses NaN check (val == val). Clever but non-obvious.

Type_Bound_Value / Type_Bound_Float_Value / Type_Bound_Is_Set (lines 15552-15578)
  Rating: A — Simple accessors

Emit_Float_Type_Min / Emit_Float_Type_Max (lines 15583-15606)
  Rating: B
  - [OPT] Hardcoded hex IEEE constants. Correct but fragile.
  - [ADA] Only handles float/double, not LONG_LONG_FLOAT

Array_Element_Count / Array_Low_Bound (lines 15609-15625)
  Rating: C
  - [ADA] Only handles first dimension! Multi-dimensional arrays broken.

Get_Dimension_Index (line 15627)
  Rating: A

Generate_Attribute (line 15633, ~1250 lines)
  Rating: D
  - MASSIVE function — by far the largest in the file
  - [DUP] FIRST/LAST code (lines 15716-15841): ~125 lines near-identical,
    only differs in low_bound vs high_bound
  - [DUP] SUCC/PRED code (lines 16052-16126): ~75 lines near-identical,
    only differs in add/sub and sgt/slt
  - [DUP] ACCESS/UNCHECKED_ACCESS (lines 16552-16576): exact duplicate,
    24 lines identical
  - [DUP] Generic formal substitution loop appears at lines 15648, 16061,
    16098 — identical 10-line blocks
  - [OPT] Attribute dispatch via string comparison chain
    (Slice_Equal_Ignore_Case for ~40 attribute names) is O(n).
    Should use hash or enum lookup.
  - [ADA] 'CONSTRAINED always returns TRUE (line 16860) — WRONG for
    unconstrained objects
  - [ADA] 'CALLABLE always returns TRUE (line 16867) — WRONG, should
    check task state
  - [ADA] 'TERMINATED always returns FALSE (line 16874) — WRONG
  - [ADA] 'IMAGE for enumeration types generates inline switch with all
    literal strings (~60 lines per type) instead of using a runtime table
  - [ADA] 'VALUE for enumeration types generates inline string comparison
    chain (~70 lines per type) instead of using a runtime table
  - [ADA] 'WIDTH runtime digit counting uses 18-element threshold array
    (lines 16514-16526) — baroque approach vs simple log10
  - [ADA] Multi-dimensional FIRST/LAST: only works for first dimension
    unless explicit dimension argument provided
  - [LIMIT] address_marker_count < 256 hardcoded limit (line 15945)
  - [GNAT] GNAT handles attributes in Sem_Attr (~8000 lines) and
    Exp_Attr (~10000 lines). This conflates semantic checking and codegen.

  Recommended refactoring:
    1. Extract Emit_First_Last(is_high) — saves ~120 lines
    2. Extract Emit_Succ_Pred(is_succ) — saves ~70 lines
    3. Merge ACCESS/UNCHECKED_ACCESS — saves ~24 lines
    4. Extract generic formal substitution to helper — saves ~30 lines
    5. Use enum/hash for attribute dispatch — saves ~80 lines
    6. Use runtime tables for IMAGE/VALUE — saves ~130 lines
  Estimated savings: ~450 lines

--- S13.4 Statement Code Generation (lines ~16900-19200) ---

Find_Record_Component (line 16885)
  Rating: C
  - [OPT] Linear search by name. Could use hash or index.

Is_Others_Choice (line 16896)
  Rating: A

Generate_Aggregate (line 16901, ~490 lines)
  Rating: C
  - Handles array and record aggregates with three-pass approach
  - [DUP] Dynamic range loop code (lines 17030-17077) nearly identical
    to others loop (lines 17091-17136) — ~45 lines duplicated
  - [DUP] Record aggregate init pattern duplicated between named and
    positional cases
  - [OPT] Array aggregate with all-static values should emit as LLVM
    constant array, not store-by-store
  - [ADA] Doesn't verify that named choices cover all index values (RM 4.3.3)

Generate_Qualified (line 17395)
  Rating: B
  - [ADA] Should emit range check for qualified expression (RM 4.7)

Generate_Allocator (line 17424, ~210 lines)
  Rating: C
  - Uses malloc for heap allocation
  - [OPT] No null check on malloc return
  - [ADA] Should raise STORAGE_ERROR if malloc fails (RM 4.8)
  - [DUP] Bound generation code duplicated from Generate_Aggregate
  - Inconsistency: elem_size fallback is sometimes 1 (line 17494),
    sometimes 8 (line 17505, 17577)

Generate_Expression (line 17636)
  Rating: A
  - Clean dispatch switch. No issues.

Generate_Statement_List (line 17682)
  Rating: B
  - Handles dead code after terminators by emitting fresh labels

Generate_Assignment (line 17711, ~400 lines)
  Rating: C
  - Handles array element, slice, .ALL dereference, selected component, simple
  - [DUP] Uplevel access check pattern (is_uplevel detection) appears ~5 times
    in this function alone, identical pattern each time
  - [DUP] Generic formal substitution loop (lines 17995+) duplicated
  - [ADA] No range check on assignment to constrained subtype
  - [ADA] Slice assignment doesn't check length match (RM 5.2.1)
  - [OPT] Record assignment uses memcpy with ty->size — should use
    alignment info for potentially better codegen

Generate_If_Statement (line 18116)
  Rating: B
  - [ADA] ELSIF parts not handled in this reading (may be in earlier chunk)
  - Clean basic block structure

Generate_Loop_Statement (line 18141)
  Rating: B
  - Handles WHILE and basic loops
  - [ADA] Loop labels correctly emit LLVM labels for GOTO targeting

Generate_For_Loop (line 18329, ~165 lines)
  Rating: C
  - [ADA] Empty range should not execute body. Current code checks
    condition at loop start — correct for forward, but reverse iteration
    with empty range may execute once.
  - [DUP] Bound extraction code (lines 18356-18445) has 5 different cases
    (NK_RANGE, NK_ATTRIBUTE, NK_SUBTYPE_INDICATION, NK_IDENTIFIER, default)
    with duplicated Emit patterns for each
  - [OPT] Loop variable is alloca'd and loaded/stored every iteration.
    Should use LLVM phi node for induction variable.

Generate_Return_Statement (line 18190)
  Rating: B
  - [ADA] No check that function returns a value on all paths

Generate_Case_Statement (line 18207, ~120 lines)
  Rating: C
  - Generates if-else chain instead of LLVM switch instruction
  - [OPT] LLVM's switch instruction would be much more efficient for
    discrete choices. The current if-chain is O(n) per case execution.
  - [ADA] Doesn't verify completeness (RM 5.4)
  - [DUP] Range check code (lines 18237-18252) duplicated for NK_RANGE
    and NK_SUBTYPE_INDICATION cases — nearly identical

Generate_Raise_Statement (line 18507)
  Rating: B
  - [ADA] Exception identity stored as i64 (pointer-to-global cast).
    This works but is non-standard.

Generate_Block_Statement (line 18531, ~150 lines)
  Rating: B
  - setjmp/longjmp exception handling
  - [GNAT] GNAT uses either ZCX (zero-cost exceptions) or SJLJ.
    This only does SJLJ.
  - [OPT] LLVM has native exception handling support (landingpad,
    invoke/unwind) which would be more efficient than setjmp

Generate_Statement (line 18684, ~490 lines)
  Rating: C
  - Central statement dispatch
  - [DUP] NK_CALL_STMT handling (lines 18692-18808) is very long (~115 lines)
    and contains duplicated patterns for:
    1. Entry calls (rendezvous setup)
    2. Parameterless procedure calls
    3. Qualified procedure calls
    Each with its own uplevel access check duplication
  - [ADA] Entry call parameter passing via i64 block is simplistic —
    doesn't handle composite parameters
  - [OPT] Rename chain following (lines 18751-18760) could be a helper

Generate_Delay (within Generate_Statement, line 18860)
  Rating: B
  - Duration -> microseconds conversion
  - [ADA] Duration is fixed-point in Ada 83 (RM 9.6), not float.
    Using fmul assumes float representation.

Generate_Accept (within Generate_Statement, line 18874)
  Rating: B
  - [LIMIT] Entry index formula: base * 1000 + family_arg. Limits
    entry families to <1000 members.

Generate_Select (within Generate_Statement, line 18941)
  Rating: C
  - [ADA] Selective wait implementation is incomplete:
    - Guard expressions ARE generated (fixes earlier parse bug?) but
      only for NK_ASSOCIATION alternatives
    - Multiple delay alternatives: only first delay's duration used
    - No timed entry call form
  - [DUP] Accept alternative code (lines 18985-19054) heavily duplicates
    the standalone Generate_Accept code
  - [LIMIT] Accept parameter loading duplicated from Generate_Accept

Generate_Abort (within Generate_Statement, line 19119)
  Rating: B

Generate_Label / Generate_Goto (within Generate_Statement, lines 19128-19168)
  Rating: A
  - Clean label/goto implementation with forward reference support

--- S13.5 Declaration Code Generation (lines ~19175-20673) ---

Generate_Declaration_List (line 19185)
  Rating: A

Generate_Object_Declaration (line 19191, ~450 lines)
  Rating: C
  - Handles variables, constants, renames, arrays, records
  - [DUP] Dynamic array bound extraction (lines 19529-19604) heavily
    duplicates pattern from Generate_For_Loop
  - [DUP] Record default initialization (lines 19605-19643) duplicates
    pattern from Generate_Aggregate
  - [OPT] All local variables use alloca even for simple scalars that
    could be SSA values
  - [ADA] Constant declarations with expressions should be evaluable
    at compile time when possible; currently always emits runtime code

Has_Nested_In_Statements (line 19651)
  Rating: B
  - Recursive check for nested subprograms in statement lists
  - [OPT] Could cache result to avoid repeated traversal

Has_Nested_Subprograms (line 19688)
  Rating: B

Generate_Subprogram_Body (line ~19720, estimated ~200 lines)
  Rating: C
  - [DUP] Function header emission pattern (define, parameters, entry block)
    is duplicated between here, Generate_Generic_Instance_Body, and
    Generate_Task_Body — ~50 lines each
  - [OPT] No inlining annotations (alwaysinline, noinline) emitted
  - [GNAT] GNAT LLVM emits proper LLVM metadata for debug info

Generate_Generic_Instance_Body (line ~19960, ~230 lines)
  Rating: C
  - [DUP] Function header emission duplicated from Generate_Subprogram_Body
  - [DUP] Parameter setup duplicated from Generate_Subprogram_Body
  - [DUP] Deferred body processing pattern duplicated
  - [DUP] Homograph matching code (lines 20029-20054) is EXACTLY duplicated
    at lines 20548-20575 — ~25 lines identical

Generate_Task_Body (line 20196, ~150 lines)
  Rating: B
  - [DUP] Function header emission duplicated again
  - [ADA] Task body gets "ptr %__parent_frame" as first parameter for
    uplevel access — correct for nested tasks

Generate_Declaration (line ~20300, ~370 lines)
  Rating: C
  - Central declaration dispatch
  - [DUP] Generic instance handling (lines ~20400-20583) has massive code
    duplication for package instance body generation
  - [LIMIT] deferred_count < 64 hardcoded
  - [LIMIT] exported_count < 100 for task entries

--- S13.6 Implicit Equality (lines ~20682-20900) ---

Generate_Type_Equality_Function (line 20683)
  Rating: B
  - linkonce_odr for deduplication — good
  - [ADA] Array equality should compare element-by-element for composite
    elements (RM 4.5.2). Currently uses memcmp.
  - [OPT] memcmp-based comparison is correct for scalar arrays but not
    for records with padding or arrays of records

Generate_Implicit_Operators (line ~20850)
  Rating: B
  - Iterates frozen types and emits equality functions

--- S13.7 Compilation Unit (lines ~21046-21686) ---

Generate_Extern_Declarations (line ~20950)
  Rating: B
  - Emits LLVM "declare" for WITH'd package subprograms

Generate_Compilation_Unit (line 21053, ~633 lines)
  Rating: C
  - [OPT] LLVM module header is ~600 lines of hardcoded Emit() calls
    for runtime support functions (__text_io_*, __ada_*). This should
    be in a separate runtime .ll file that gets linked in.
  - [OPT] Integer'VALUE runtime (lines 21094-21138) is emitted as inline
    LLVM IR — should be a compiled runtime library function
  - [OPT] __ada_integer_pow uses linear loop instead of binary
    exponentiation (lines 21152-21172)
  - [OPT] TEXT_IO runtime functions are emitted in every .ll file due to
    linkonce_odr — wasteful during compilation even if deduped at link
  - [ADA] PUT_INTEGER ignores Width parameter (line 21553) — format
    string is just "%lld" with no padding
  - [ADA] GET_LINE hardcoded 256 byte buffer (line 21575)
  - [LIMIT] 64 compilation units per file (line 22193)

SECTION 13 SUMMARY:
  Code generator is functional but has extensive duplication:
  - Uplevel access check: ~10 instances of identical 4-line pattern
  - Generic formal substitution: ~5 instances of identical 10-line loop
  - Function header emission: ~3 instances of ~50-line blocks
  - Homograph matching: 2 exact copies of ~25-line blocks
  - Bound extraction: ~4 instances of similar 30-line patterns

  Missing from GNAT LLVM:
  - No LLVM switch instruction (uses if-chain for CASE)
  - No ZCX exceptions (setjmp only)
  - No debug info metadata
  - No LLVM struct types for records
  - No inlining hints
  - No overflow checks on arithmetic

  Estimated deduplication savings: ~800 lines

================================================================================
 S14. INCLUDE PATH & PACKAGE LOADING (lines ~21692-22145)
================================================================================

Include_Paths / Include_Path_Count (line 21693)
  Rating: C
  - [LIMIT] 32 include paths max
  - [LIMIT] 128 loaded package bodies max

Lookup_Path / Lookup_Path_Body (lines ~21710-21760)
  Rating: B
  - Searches include paths for .ads/.adb files

Load_Package_Spec (line ~21800, ~340 lines)
  Rating: C
  - Loads and resolves WITH'd package specifications
  - [DUP] INSTALL_DECL_SYMBOLS macro (lines 22100-22121) is defined
    as a multi-line macro to avoid function extraction — should be a
    proper function
  - [DUP] Generic formal installation in package body loading (lines
    22072-22097) duplicates code from Resolve_Declaration
  - [ADA] Circular dependency detection via Loading_Set is good
  - [LIMIT] Loading_Set max 64 entries

Has_Precompiled_LL (line ~21780)
  Rating: B

Body_Already_Loaded / Mark_Body_Loaded (lines ~21790-21810)
  Rating: B

SECTION 14 SUMMARY:
  Package loading works but has many hardcoded limits and duplicated
  symbol installation code.

================================================================================
 S15. MAIN DRIVER (lines ~22148-22450)
================================================================================

Read_File (line 22152)
  Rating: B
  - Standard fopen/fseek/fread pattern

Compile_File (line 22178, ~250 lines)
  Rating: B
  - Parse -> resolve -> generate pipeline
  - [LIMIT] 64 compilation units per file
  - [OPT] No parallel compilation support

main (line ~22380)
  Rating: B
  - Command-line argument parsing with -I, -o, -c flags
  - [OPT] No --help or --version flags
  - [LIMIT] Fixed-size filename buffers (256 chars)

SECTION 15 SUMMARY:
  Clean driver. No major issues beyond hardcoded limits.

================================================================================
 S16. ALI FILE FORMAT (lines ~22450-23400)
================================================================================

Crc32 (line ~22460)
  Rating: A
  - Standard CRC-32 implementation

ALI_Info / Unit_Info / Export_Info structs (lines ~22470-22500)
  Rating: B

Generate_ALI_File (line ~22530, ~120 lines)
  Rating: B
  - Emits GNAT-compatible .ali files

ALI_Collect_Withs (line ~22550)
  Rating: B

ALI_Collect_Unit (line 22507)
  Rating: B

ALI_Collect_Exports (line 22593)
  Rating: B

LLVM_Type_Basic (line 22575)
  Rating: C
  - [DUP] Type-to-LLVM mapping duplicated from Type_To_Llvm and
    Expression_Llvm_Type
  - String comparison chain for type names — O(n)

ALI_Read (line ~22900, ~200 lines)
  Rating: B
  - Parses .ali files back

ALI_Is_Current (line 23110)
  Rating: B

ALI_Find (line 23126)
  Rating: B

ALI_Load_Symbols (line 23152)
  Rating: B
  - Recursive dependency loading from .ali files

SECTION 16 SUMMARY:
  ALI support is functional and GNAT-compatible. Type mapping is duplicated.

================================================================================
 S17. GENERIC EXPANSION (lines ~23350-23734)
================================================================================

Node_Deep_Clone (line ~23370, ~255 lines)
  Rating: C
  - Deep AST clone with substitution environment
  - [ADA] Default case does shallow copy with *n = *node — may create
    aliased subtrees for unhandled node kinds, leading to mutation bugs
  - [DUP] The switch has ~30 cases that each follow the same pattern:
    clone children, copy scalar fields. Could use a node descriptor table.
  - [LIMIT] Depth parameter passed but never checked for stack overflow

Node_List_Clone (line ~23360)
  Rating: B

Build_Instantiation_Env (line 23630)
  Rating: B
  - [LIMIT] Max 32 generic formals (env->mappings[env->count++] with
    count bounded by 32)

Expand_Generic_Package (line 23677)
  Rating: C
  - Clones spec and body with type substitutions
  - [ADA] Doesn't re-resolve cloned trees — comment says "Resolve cloned
    trees with actual types" but no resolution call is made
  - [GNAT] GNAT's Sem_Ch12.Instantiate_Package_Body does full
    re-analysis of the cloned body
  - [OPT] Body source is re-parsed from file every time — should cache
    parsed ASTs

SECTION 17 SUMMARY:
  Generic expansion via AST cloning works for simple cases but lacks
  re-resolution, which means complex generics with type-dependent
  overloading will fail silently.

================================================================================
 GLOBAL STATISTICS
================================================================================

Total functions audited:   ~180+
Rating distribution:
  A (excellent):     ~20   (11%)
  B (good):          ~70   (39%)
  C (fair):          ~75   (42%)
  D (poor):          ~5    (3%)
  F (needs rewrite): ~0    (0%)
  (Remaining ~10 are struct/enum definitions without functions)

Top line-saving opportunities (estimated):
  1. SIMD whitespace dedup (S7):        ~300 lines
  2. Generate_Attribute refactor (S13):  ~450 lines
  3. Codegen duplication (S13):          ~800 lines
  4. Parser exception handler dedup (S9):~350 lines
  5. Semantic analysis dedup (S12):      ~400 lines
  6. Runtime to separate .ll file (S13): ~600 lines
  TOTAL POTENTIAL REDUCTION:            ~2900 lines (12% of file)

================================================================================
 CRITICAL ADA SEMANTICS BUGS
================================================================================

1. SELECT guard expressions parsed but discarded in Parse_Select_Statement
   (S9, line ~4700) — guards are IGNORED at runtime. RM 9.7.1 violation.

2. 'CONSTRAINED always returns TRUE (S13, line 16860) — should check
   whether the object's discriminants are constrained. RM 3.7.2.

3. 'CALLABLE always returns TRUE (S13, line 16867) — should check task
   state. RM 9.9.

4. 'TERMINATED always returns FALSE (S13, line 16874) — should check
   task state. RM 9.9.

5. No overflow checks on integer arithmetic (S13) — all of +, -, *
   should potentially raise Constraint_Error. RM 4.5.

6. No range checks on assignment to constrained subtypes (S13) —
   RM 5.2 requires check.

7. No range checks on type conversions (S13) — RM 4.6 requires check.

8. No array bounds checks on indexing (S13) — RM 4.1.1 requires check.

9. CASE statement completeness not verified (S12) — RM 5.4 requires
   all values of the discrete type to be covered.

10. Subprogram body conformance with spec not checked (S12) — RM 6.3.1.

11. Array_Element_Count / Array_Low_Bound only handle first dimension
    (S13, lines 15609-15625) — multi-dimensional arrays broken for
    these helpers.

12. PUT_INTEGER ignores Width parameter (S13, line 21553).

13. Duration treated as float instead of fixed-point (S13, line 18860).

14. Expanded generics not re-resolved (S17, line 23677).

================================================================================
 MISSING GNAT sem_util.ads PREDICATES
================================================================================

The following GNAT predicates have no equivalent in ada83.c and their
absence leads to incomplete or incorrect semantic checking:

  Is_Scalar_Type           — partial (Type_Is_Scalar exists but incomplete)
  Is_Discrete_Type         — partial
  Is_Numeric_Type          — partial
  Is_Array_Type            — missing (uses kind == TYPE_ARRAY inline)
  Is_Record_Type           — missing
  Is_Access_Type           — missing
  Is_Fixed_Point_Type      — missing
  Is_Float_Type            — missing
  Is_Private_Type          — missing
  Is_Limited_Type          — missing
  Is_Constrained           — missing
  Is_Overloaded            — missing
  Has_Discriminants        — missing
  Has_Private_Component    — missing (ref: sem_util.ads:1583)
  Has_Static_Array_Bounds  — partial (Type_Has_Dynamic_Bounds is inverse)
  Has_Defaulted_Discriminants — missing (ref: sem_util.ads:1407)
  Has_Preelaborable_Initialization — missing (ref: sem_util.ads:1569)
  Has_Signed_Zeros         — missing (ref: sem_util.ads:1593)
  Has_Denormals            — missing (ref: sem_util.ads:1413)
  Has_Infinities           — missing (ref: sem_util.ads:1459)
  In_Instance              — missing (ref: sem_util.ads:1675)
  In_Visible_Part          — missing (ref: sem_util.ads:1749)
  All_Composite_Constraints_Static — missing (ref: sem_util.ads:108)

================================================================================
 HARDCODED LIMITS SUMMARY
================================================================================

  Arena page size:          16 MB
  Include paths:            32
  Loaded package bodies:    128
  Loading set:              64
  Compilation units/file:   64
  Deferred bodies:          64
  Exception globals:        256
  Task exports:             100
  Address markers:          256
  Generic formals:          32
  ALI exports:              256
  Entry family members:     <1000 (via * 1000 encoding)
  Filename buffers:         256 chars
  GET_LINE buffer:          256 bytes

================================================================================
 END OF AUDIT
================================================================================
