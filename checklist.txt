================================================================================
                    ADA83.C ELABORATION MODEL REFACTORING
                         Comprehensive Checklist
================================================================================

ORIGINAL PROMPT:
--------------------------------------------------------------------------------
In the pursuit of high-quality code (low line count (e.g. low undue complexity)
and high feature/correctness) - refactor ada83.c to have the full and complete
GNAT LLVM elaboration model with much better Haskell-like C99 and tight smart
code-golfing with, ironically, textbook "Literate Programming" style. Use the
GNAT LLVM sources in the repo to see what is done there before making changes.
--------------------------------------------------------------------------------

================================================================================
                              MASTER PLAN
================================================================================

PHASE 1: ANALYSIS & DESIGN
--------------------------
[x] 1.1 Study GNAT LLVM elaboration architecture:
    - bindo-elaborators.adb: Main elaboration algorithm
    - bindo-graphs.ads: Library graph and invocation graph structures
    - sem_elab.ads: Semantic elaboration analysis
    - gnatllvm-compile.adb: Code generation integration

[x] 1.2 Document current ada83.c elaboration model:
    - Location: lines 16256-16258 (elab_funcs array), 29400-29900 (generation)
    - Limitations: No dependency graph, source-order elaboration only
    - Current capacity: 64 packages max

[x] 1.3 Design new elaboration model data structures (Haskell-like C99):
    - Library_Graph: Vertices (units) + Edges (dependencies)
    - Invocation_Graph: Call-flow at elaboration time
    - Component tracking for cyclic dependency handling
    - Edge classification: With, Elaborate, Elaborate_All, Spec_Before_Body

PHASE 2: CORE DATA STRUCTURES
-----------------------------
[x] 2.1 Define algebraic data types (tagged unions):
    - Elab_Unit_Kind: {UNIT_SPEC, UNIT_BODY, UNIT_SPEC_ONLY, UNIT_BODY_ONLY}
    - Elab_Edge_Kind: {EDGE_WITH, EDGE_ELABORATE, EDGE_ELABORATE_ALL,
                       EDGE_SPEC_BEFORE_BODY, EDGE_INVOCATION, EDGE_FORCED}
    - Elab_Precedence: {PREC_HIGHER, PREC_EQUAL, PREC_LOWER}
    - Elab_Order_Status: {ELAB_ORDER_OK, ELAB_ORDER_HAS_CYCLE, ...}

[x] 2.2 Define graph vertex structure (Elab_Vertex):
    - id, name, kind, symbol
    - component_id (for SCC analysis)
    - pending_strong, pending_weak
    - in_elab_order flag
    - body_vertex, spec_vertex (for spec/body pairing)
    - is_preelaborate, is_pure, has_elab_body, is_predefined, is_internal

[x] 2.3 Define graph edge structure (Elab_Edge):
    - id, kind, is_strong
    - pred_vertex_id, succ_vertex_id
    - Intrusive linked list threading (next_pred_edge, next_succ_edge)

[x] 2.4 Define graph structure (Elab_Graph):
    - vertices[ELAB_MAX_VERTICES=512]
    - edges[ELAB_MAX_EDGES=2048]
    - component_pending_strong/weak[ELAB_MAX_COMPONENTS=256]
    - order[ELAB_MAX_VERTICES] (result array)

PHASE 3: GRAPH CONSTRUCTION
---------------------------
[x] 3.1 Elab_Add_Vertex():
    - Create vertices for each compilation unit
    - Auto-detect predefined units (Ada.*, System.*, Interfaces.*)
    - Auto-detect internal units (GNAT.*)

[x] 3.2 Elab_Add_Edge():
    - Add edges for WITH clauses (EDGE_WITH)
    - Add edges for pragma Elaborate (EDGE_ELABORATE)
    - Add edges for pragma Elaborate_All (EDGE_ELABORATE_ALL)
    - Add spec-before-body edges (EDGE_SPEC_BEFORE_BODY)
    - Duplicate edge detection

[x] 3.3 Elab_Pair_Specs_Bodies():
    - Match spec vertices with their body vertices
    - Add spec-before-body edges automatically

[x] 3.4 Elab_Find_Components() - Tarjan's SCC algorithm:
    - Identify strongly connected components
    - Assign component IDs to vertices
    - Calculate component-level predecessor counts
    - Detect Elaborate_All cycles (fatal)

PHASE 4: ELABORATION ALGORITHM
------------------------------
[x] 4.1 Elab_Vertex_Set (bitmap representation):
    - O(1) membership testing via bit manipulation
    - Insert, Remove, Contains, Size operations
    - Brian Kernighan's popcount trick

[x] 4.2 Elab_Find_Best_Vertex():
    - Higher-order function with predicate and comparator
    - Scans candidate set for optimal vertex

[x] 4.3 Elab_Compare_Vertices() - Priority ordering (from GNAT LLVM):
    1. Spec with Elaborate_Body before its body
    2. Predefined units (Ada.*, System.*, Interfaces.*)
    3. Internal units (GNAT.*)
    4. Preelaborated units
    5. Pure units
    6. Lexicographical tiebreaker

[x] 4.4 Elab_Elaborate_Vertex():
    - Mark vertex as elaborated
    - Add to elaboration order
    - Update all successors via Elab_Update_Successor()
    - Handle Elaborate_Body pairs (elaborate body immediately after spec)

[x] 4.5 Elab_Elaborate_Graph():
    - Main elaboration loop
    - Partition vertices: elaborable vs waiting
    - Find best elaborable vertex (priority order)
    - If none, try weak elaboration (cycles)
    - Cycle detection and reporting

[x] 4.6 Elab_Compare_Weak():
    - For handling unavoidable cycles
    - Prefer vertices with fewer weak predecessors

PHASE 5: CODE GENERATION INTEGRATION
------------------------------------
[x] 5.1 Register units with elaboration graph:
    - Elab_Register_Unit() called when package body __elab generated
    - Elab_Register_Unit() called when generic instance __elab generated

[x] 5.2 Refactor main() generation (lines 32587-32641):
    - Call Elab_Compute_Order() before generating @main
    - Use computed order (Elab_Get_Order_Count/Symbol)
    - Skip pure/preelaborate units via Elab_Needs_Elab_Call()
    - Fallback to source order if cycle detected

[x] 5.3 Cycle diagnostics:
    - ELAB_ORDER_HAS_ELABORATE_ALL_CYCLE: Fatal error message
    - ELAB_ORDER_HAS_CYCLE: Warning, use source order

PHASE 6: PRAGMA SUPPORT
-----------------------
[x] 6.1 pragma Elaborate:
    - EDGE_ELABORATE edge kind
    - Edge_Kind_Is_Strong() returns true

[x] 6.2 pragma Elaborate_All:
    - EDGE_ELABORATE_ALL edge kind
    - Detected in cycle checking (fatal if in SCC)

[x] 6.3 pragma Preelaborate:
    - is_preelaborate flag on vertex
    - Higher priority in Elab_Compare_Vertices()
    - Elab_Needs_Elab_Call() skips if no explicit elab code

[x] 6.4 pragma Pure:
    - is_pure flag on vertex
    - Elab_Needs_Elab_Call() always skips pure units

PHASE 7: OPTIMIZATION & CLEANUP
-------------------------------
[x] 7.1 Merge new code into ada83.c (single-file constraint)
    - Added as section 15.7 (lines 12682-13535)
    - ~850 lines of new elaboration model code

[x] 7.2 Old elab_funcs[64] array kept for backward compatibility
    - New model is primary; old array is fallback

[x] 7.3 Haskell-like style applied:
    - Algebraic data types via enums and structs
    - Pure functions (predicates, comparators)
    - Higher-order functions (Elab_Find_Best_Vertex with function pointers)
    - Compound literals for initialization
    - Inline functions for performance

[x] 7.4 Code-golfing applied:
    - Ternary operators for simple conditionals
    - Dense but readable inline functions
    - Bitmap operations for vertex sets
    - Intrusive linked lists for edge iteration

[x] 7.5 Literate programming documentation:
    - Major section header (15.7)
    - Subsection headers (15.7.1-15.7.12)
    - Algorithm descriptions inline
    - Cross-references to GNAT LLVM sources and Ada RM

================================================================================
                            STYLE GUIDELINES
================================================================================

HASKELL-LIKE C99 PATTERNS USED:
-------------------------------
1. Tagged unions for sum types:
   - Elab_Unit_Kind, Elab_Edge_Kind, Elab_Precedence (enums)
   - Elab_Vertex, Elab_Edge (tagged structures)

2. Option types:
   - Return 0 for "not found" (vertex IDs are 1-based)
   - NULL checks for pointers

3. Pure functions (no side effects except return):
   - Elab_Is_Elaborable(), Elab_Is_Weakly_Elaborable()
   - Elab_Compare_Vertices(), Elab_Compare_Weak()
   - Edge_Kind_Is_Strong()

4. Higher-order functions:
   - Elab_Find_Best_Vertex() takes predicate and comparator

5. Compound literals:
   - Elab_Graph_New() returns (Elab_Graph){0}
   - Vertex/edge initialization with designated initializers

CODE-GOLFING TECHNIQUES USED:
-----------------------------
1. Ternary operators: return cond ? a : b
2. Inline functions: static inline bool ...
3. Bitmap sets: 64-bit words with bit manipulation
4. Brian Kernighan popcount: while (v) { count++; v &= v-1; }
5. 1-based IDs: 0 means "not found/invalid"
6. Intrusive lists: edges threaded through vertices

LITERATE PROGRAMMING FORMAT:
----------------------------
/* ═══════════════════════════════════════════════════════════════════════════
 * §15.7 ELABORATION MODEL — GNAT LLVM-Style Dependency Graph Algorithm
 *
 * [High-level description with references]
 * ═══════════════════════════════════════════════════════════════════════════ */

/* ─────────────────────────────────────────────────────────────────────────
 * §15.7.X Subsection Title
 *
 * [Detailed explanation, algorithm steps, invariants]
 * ───────────────────────────────────────────────────────────────────────── */

================================================================================
                      IMPLEMENTATION SUMMARY
================================================================================

NEW SECTION: §15.7 ELABORATION MODEL (lines 12682-13535)
--------------------------------------------------------
15.7.1  Algebraic Types          - Sum types via enums
15.7.2  Graph Vertex             - Elab_Vertex structure
15.7.3  Graph Edge               - Elab_Edge structure
15.7.4  Graph Structure          - Elab_Graph with max capacities
15.7.5  Graph Construction       - Elab_Add_Vertex(), Elab_Add_Edge()
15.7.6  Tarjan's SCC Algorithm   - Elab_Find_Components()
15.7.7  Vertex Predicates        - Pure functions for decisions
15.7.8  Vertex Set Operations    - Bitmap set with O(1) operations
15.7.9  Best Vertex Selection    - Higher-order Elab_Find_Best_Vertex()
15.7.10 Elaboration Core         - Main algorithm loop
15.7.11 Build from ALI           - Integration with ALI system
15.7.12 Elaboration Order API    - Public interface functions

MODIFIED SECTIONS:
------------------
- §13 Code_Generator (NK_PACKAGE_BODY): Added Elab_Register_Unit() calls
- §17 Main_Driver (@main generation): Uses Elab_Compute_Order()

STATISTICS:
-----------
- New code added: ~850 lines
- Complexity: O(V+E) for graph construction and Tarjan's SCC
- Memory: Fixed arrays (no dynamic allocation)
- Max capacity: 512 vertices, 2048 edges, 256 components

================================================================================
                              PROGRESS LOG
================================================================================

[2026-02-05] Initial analysis complete:
  - Reviewed bindo-elaborators.adb (1695 lines)
  - Reviewed bindo-graphs.ads (1500+ lines)
  - Reviewed current ada83.c elaboration (~400 lines in scattered locations)
  - Identified key differences and gaps

[2026-02-05] Implementation complete:
  - Added full GNAT LLVM-style elaboration model (§15.7)
  - Implemented Tarjan's SCC algorithm for cycle detection
  - Implemented priority-based vertex selection
  - Integrated with Code_Generator for @main emission
  - Build verified successful (gcc -O2 -Wall)
  - Test compilation verified (hello world with TEXT_IO)

VERIFIED WORKING:
  - @main() emits elaboration calls in computed order
  - TEXT_IO___elab called before HELLO
  - Fallback to source order on cycle detection
  - Pure/preelaborate optimization skips unnecessary calls

================================================================================



================================================================================
                    LIMITED TYPES — BUILD-IN-PLACE MODEL
                         Comprehensive Master Plan
================================================================================

ORIGINAL PROMPT:
--------------------------------------------------------------------------------
Make a master plan for the implementation of "Limited Types" using the
"Build in place" model. Also don't reference GNAT LLVM in the source
comments - sounds lame.
--------------------------------------------------------------------------------

================================================================================
                              OVERVIEW
================================================================================

Build-in-Place (BIP) is the canonical implementation strategy for Ada limited
types. Limited types cannot be copied, so functions returning them must
construct the result directly in the caller's destination—no intermediate
temporaries, no assignment. This is fundamentally different from non-limited
returns where the function builds a local object and copies it out.

Key insight: BIP transforms function returns into an OUT-parameter protocol,
passing allocation information and a destination pointer INTO the function.

Ada 83 Limited Types (RM 7.4.4):
  - Records with limited components
  - Task types (always limited)
  - Private types declared "limited private"
  - Types derived from limited types

================================================================================
                              MASTER PLAN
================================================================================

PHASE 1: ANALYSIS & DESIGN
--------------------------
[ ] 1.1 Study reference implementation architecture:
    - exp_ch6.adb: Function return expansion (10,694 lines)
    - sem_ch6.adb: Subprogram semantic analysis (14,385 lines)
    - exp_util.adb: BIP utility functions
    - einfo.ads: Entity information for BIP flags

[ ] 1.2 Document current ada83.c limited type handling:
    - Identify existing limited type detection
    - Map current function return codegen
    - Document aggregate handling for limited types
    - Identify gaps vs. full BIP model

[ ] 1.3 Design BIP data structures (Haskell-like C99):
    - BIP_Alloc_Form: Sum type for allocation strategy
    - BIP_Formal_Kind: Sum type for extra parameter kinds
    - BIP_Context: Record for call-site transformation state
    - BIP_Return_Info: Record for return statement expansion

PHASE 2: CORE ALGEBRAIC TYPES
-----------------------------
[ ] 2.1 Define BIP_Alloc_Form enum:
    typedef enum {
        BIP_ALLOC_UNSPECIFIED,      /* Let callee decide (default)        */
        BIP_ALLOC_CALLER,           /* Caller provides space (stack/obj)  */
        BIP_ALLOC_SECONDARY_STACK,  /* Use secondary stack                */
        BIP_ALLOC_GLOBAL_HEAP,      /* Use heap (new/allocator)           */
        BIP_ALLOC_USER_POOL         /* User-defined storage pool          */
    } BIP_Alloc_Form;

[ ] 2.2 Define BIP_Formal_Kind enum:
    typedef enum {
        BIP_FORMAL_ALLOC_FORM,      /* Allocation strategy selector       */
        BIP_FORMAL_STORAGE_POOL,    /* Pool for user-pool allocation      */
        BIP_FORMAL_FINALIZATION,    /* Finalization collection access     */
        BIP_FORMAL_TASK_MASTER,     /* Task master for task components    */
        BIP_FORMAL_ACTIVATION,      /* Activation chain for tasks         */
        BIP_FORMAL_OBJECT_ACCESS    /* Pointer to destination space       */
    } BIP_Formal_Kind;

[ ] 2.3 Define BIP_Context structure:
    typedef struct {
        Symbol *func;               /* Function being called              */
        Node   *call_node;          /* Call expression AST                */
        Node   *target;             /* Destination (NULL = temp needed)   */
        BIP_Alloc_Form alloc_form;  /* Determined allocation strategy     */
        Symbol *storage_pool;       /* Pool symbol (if user pool)         */
        Symbol *finalization_coll;  /* Finalization collection            */
        Symbol *task_master;        /* Task master (if tasks present)     */
        Symbol *activation_chain;   /* Activation chain (if tasks)        */
        bool   needs_finalization;  /* Type has controlled components     */
        bool   has_task_components; /* Type has task components           */
    } BIP_Context;

PHASE 3: TYPE PREDICATES (Pure Functions)
-----------------------------------------
[ ] 3.1 Is_Limited_Type(type) — Core predicate:
    - Returns true for: explicit "limited", task types, protected types,
      types with limited components, limited private views
    - Must handle derived types (inherit limitedness)
    - Must handle private type completion

[ ] 3.2 Is_Build_In_Place_Result_Type(type) — BIP eligibility:
    - Returns true if function returning this type needs BIP
    - Criteria: Is_Limited_Type AND (Is_Tagged OR Has_Task_Components
      OR Has_Controlled_Components OR Is_Explicitly_Limited)
    - Ada 83 note: No tagged types, focus on tasks and explicit limited

[ ] 3.3 Needs_BIP_Alloc_Form(func) — Does callee need alloc form?
    - True if result type size not statically known
    - True if unconstrained or class-wide (Ada 95+)
    - Ada 83: Mainly for unconstrained array returns

[ ] 3.4 Needs_BIP_Finalization(type) — Finalization chain needed?
    - True if type has controlled components
    - Ada 83: No controlled types, but useful for extension

[ ] 3.5 Needs_BIP_Task_Info(type) — Task master/chain needed?
    - True if type has task components (direct or nested)
    - Must recursively check component types
    - Task types themselves need this for activation

[ ] 3.6 Has_BIP_Extra_Formals(func) — Does function have BIP params?
    - True if Is_Build_In_Place_Result_Type(Return_Type(func))
    - Cached on function symbol for efficiency

PHASE 4: EXTRA FORMAL PARAMETERS
--------------------------------
[ ] 4.1 BIP_Add_Extra_Formals(func):
    - Called during subprogram elaboration
    - Adds hidden parameters BEFORE the explicit formals
    - Order: Alloc_Form, Storage_Pool, Finalization, Task_Master,
             Activation_Chain, Object_Access
    - Naming: __BIPalloc, __BIPpool, __BIPfinal, __BIPmaster,
              __BIPchain, __BIPaccess

[ ] 4.2 Extra formal symbol creation:
    - Create Symbol with HIDDEN flag set
    - Link into function's formal chain
    - Set appropriate types:
      * __BIPalloc:  Integer (enum value)
      * __BIPpool:  Pointer to storage pool (System.Address)
      * __BIPfinal: Pointer to finalization collection
      * __BIPmaster: Task master ID (Integer)
      * __BIPchain: Pointer to activation chain
      * __BIPaccess: Pointer to result type

[ ] 4.3 BIP_Get_Extra_Formal(func, kind):
    - Retrieve specific BIP formal by kind
    - Used in call-site expansion and return expansion

PHASE 5: CALL-SITE TRANSFORMATION
---------------------------------
[ ] 5.1 BIP_Determine_Alloc_Form(context):
    - Simple declaration: CALLER (stack space)
    - Allocator (new): GLOBAL_HEAP or USER_POOL
    - Return statement: Propagate caller's form
    - Aggregate in place: CALLER
    - Nested call: Propagate outer context

[ ] 5.2 BIP_Expand_Call(context):
    Main call-site transformation:

    BEFORE:  X : T := F(args);
    AFTER:   F(__BIPalloc => CALLER,
               __BIPaccess => X'Address,
               args);

    - Rewrite call to include extra actuals
    - For CALLER alloc: pass address of destination
    - For HEAP alloc: pass null (callee allocates)
    - Handle nested function calls (propagate BIP)

[ ] 5.3 BIP_Expand_Allocator(alloc_node):
    Transform: P := new T'(F(args))

    - Determine pool (default or user-specified)
    - Set alloc_form = GLOBAL_HEAP or USER_POOL
    - Allocate space first (or let callee do it)
    - Pass allocated address as __BIPaccess

[ ] 5.4 BIP_Expand_Return_Call(return_node, inner_call):
    Transform: return F(args);  -- in BIP function

    - Propagate outer BIP formals to inner call
    - __BIPalloc => Outer.__BIPalloc
    - __BIPaccess => Outer.__BIPaccess
    - Chain finalization/task info

[ ] 5.5 BIP_Expand_Aggregate(agg_node, dest):
    Transform: X : T := (field1 => val1, ...);

    - Build aggregate directly into destination
    - No temporary needed for limited aggregates
    - Becomes series of component assignments

PHASE 6: RETURN STATEMENT EXPANSION
-----------------------------------
[ ] 6.1 BIP_Expand_Return_Stmt(return_node):
    Main return transformation for BIP functions:

    Original: return (field1 => expr1, field2 => expr2);

    Expanded (conceptually):
      case __BIPalloc is
        when CALLER =>
          -- Build into caller's space
          __BIPaccess.field1 := expr1;
          __BIPaccess.field2 := expr2;
        when SECONDARY_STACK =>
          -- Allocate on secondary stack
          tmp := SS_Allocate(T'Size);
          tmp.field1 := expr1;
          tmp.field2 := expr2;
          __BIPaccess.all := tmp;  -- Actually just set the out-pointer
        when GLOBAL_HEAP =>
          -- Allocate on heap
          tmp := new T;
          tmp.field1 := expr1;
          tmp.field2 := expr2;
        when USER_POOL =>
          -- Use provided pool
          tmp := Allocate(pool, T'Size);
          ...
      end case;
      -- Attach to finalization chain if needed
      -- Activate tasks if present

[ ] 6.2 BIP_Return_Simple_Expression(return_node):
    Handle: return X; -- where X is a limited object

    - Copy X's value into __BIPaccess target
    - For task types: Transfer task identity
    - For controlled: Adjust finalization chain

[ ] 6.3 BIP_Return_Function_Call(return_node):
    Handle: return F(args); -- nested BIP call

    - Expand as BIP call with propagated BIP params
    - No local temporary needed
    - Direct build-through to outer destination

PHASE 7: TASK COMPONENT HANDLING
--------------------------------
[ ] 7.1 Task activation chain threading:
    - Task components must be activated after construction
    - Activation chain links tasks for batch activation
    - Chain passed via __BIPchain parameter

[ ] 7.2 Task master management:
    - Tasks need a master for termination/exception handling
    - Master ID passed via __BIPmaster parameter
    - Enclosing construct is typically the master

[ ] 7.3 BIP_Initialize_Task_Components(type, dest):
    - Iterate task components
    - Link each into activation chain
    - Set task master
    - Defer activation until all components built

[ ] 7.4 BIP_Activate_Tasks(chain):
    - Called after aggregate/return completion
    - Activates all tasks on the chain
    - Runtime call: __gnat_activate_tasks(chain)

PHASE 8: FINALIZATION INTEGRATION (Future)
------------------------------------------
Note: Ada 83 doesn't have controlled types, but design for extension.

[ ] 8.1 Finalization collection management:
    - Track objects for finalization
    - Collection passed via __BIPfinal parameter

[ ] 8.2 BIP_Attach_To_Collection(obj, coll):
    - Link object into finalization collection
    - Happens after construction complete

[ ] 8.3 BIP_Detach_From_Collection(obj):
    - Remove from collection (on move/transfer)

PHASE 9: CODE GENERATION
------------------------
[ ] 9.1 BIP function prologue:
    - Access BIP extra formals
    - Set up local state based on __BIPalloc

[ ] 9.2 BIP return codegen:
    - Generate allocation code (if needed)
    - Generate component-by-component build
    - Generate task activation (if needed)
    - Generate finalization attachment (if needed)

[ ] 9.3 BIP call site codegen:
    - Compute extra actual values
    - Generate call with extra arguments
    - Handle result (may be in-place or allocated)

[ ] 9.4 IR representation:
    - BIP functions marked in symbol table
    - Extra formals visible in parameter list
    - Call nodes include extra actuals

PHASE 10: OPTIMIZATION
----------------------
[ ] 10.1 BIP elision for simple cases:
    - Known CALLER allocation → direct build
    - Eliminate runtime allocation form check when static

[ ] 10.2 Inline small BIP returns:
    - For small fixed-size types, inline the build

[ ] 10.3 Secondary stack optimization:
    - Batch allocations
    - Mark-release around calls

PHASE 11: INTEGRATION & TESTING
-------------------------------
[ ] 11.1 Integration with existing limited type handling:
    - Ensure backward compatibility
    - Fallback for unsupported cases

[ ] 11.2 Test cases:
    - Simple limited record return
    - Limited record with task component
    - Nested BIP calls (return F(G(x)))
    - Allocator with BIP (new T'(F(x)))
    - Aggregates of limited types
    - Limited private types

[ ] 11.3 Error handling:
    - Detect illegal copies of limited types
    - Proper error messages for BIP failures

================================================================================
                            IMPLEMENTATION ORDER
================================================================================

Recommended implementation sequence:

FOUNDATION (Must do first):
  2.1 → 2.2 → 2.3  (Core types)
  3.1 → 3.2        (Essential predicates)
  4.1 → 4.2 → 4.3  (Extra formals infrastructure)

CORE FUNCTIONALITY:
  5.1 → 5.2        (Basic call transformation)
  6.1              (Basic return expansion)
  9.1 → 9.2 → 9.3  (Code generation)

TASK SUPPORT (If tasks implemented):
  3.5              (Task predicate)
  7.1 → 7.2 → 7.3 → 7.4  (Full task chain handling)

ADVANCED:
  5.3              (Allocator support)
  5.4              (Nested return calls)
  5.5              (Aggregate expansion)
  10.1 → 10.2      (Optimizations)

================================================================================
                          STYLE NOTES
================================================================================

NO "GNAT LLVM" REFERENCES IN SOURCE:
------------------------------------
Use these alternatives in comments:
  - "Standard Ada elaboration model" instead of "GNAT LLVM elaboration"
  - "Build-in-Place protocol" instead of "GNAT BIP"
  - "RM 7.6" or "RM 9.2" instead of citing GNAT implementation
  - "Industry-standard approach" for general techniques

LITERATE PROGRAMMING FORMAT:
----------------------------
/* ═══════════════════════════════════════════════════════════════════════════
 * §15.8 BUILD-IN-PLACE — Limited Type Function Returns
 *
 * Implements the standard Build-in-Place protocol for Ada limited types.
 * Limited types cannot be copied, so functions returning them construct
 * the result directly in caller-provided space.
 *
 * Reference: Ada RM 7.5 (Limited Types), 7.6 (Controlled Types)
 * ═══════════════════════════════════════════════════════════════════════════ */

HASKELL-LIKE C99 PATTERNS:
--------------------------
1. Sum types via enums (BIP_Alloc_Form, BIP_Formal_Kind)
2. Product types via structs (BIP_Context)
3. Pure predicates (Is_Limited_Type, Needs_BIP_*)
4. Higher-order functions where applicable
5. Compound literals for initialization
6. Option type via NULL/0 sentinel

CODE-GOLFING:
-------------
1. Ternary operators for simple branches
2. Inline functions for predicates
3. Bitflags for type properties where sensible
4. Direct struct returns (no out-params for small types)

================================================================================
                              STATISTICS
================================================================================

Estimated new code: ~600-800 lines
Estimated sections: §15.8.1 through §15.8.10

Key files to modify:
  - ada83.c: Add BIP section after elaboration model
  - Integrate with existing type analysis
  - Integrate with existing code generator

================================================================================



================================================================================
                    CODE GENERATOR / EXPANDER REFACTORING
                         Comprehensive Master Plan
================================================================================

ORIGINAL PROMPT:
--------------------------------------------------------------------------------
Create a master plan for the expander as a whole with the goal of distilling it
down into a masterwork - no more repetitive patterns, janky workarounds, no
"DRY" or "KISS" violations, and as little hard coded types as possible. Each
function must be read and given a rating out of 10. We must dramatically reduce
lines of code without losing *any* functionality.
--------------------------------------------------------------------------------

================================================================================
                              CURRENT STATE ANALYSIS
================================================================================

FILE STATISTICS:
----------------
  Total lines in ada83.c:           33,330
  Code generation section:          Lines 17,500 - 31,840 (~14,340 lines)
  Total codegen functions:          53+
  Total Emit() calls:               912+
  Type conversion calls:            227
  Fat pointer operations:           168
  Type tracking calls:              143
  GEP emissions:                    114
  Conditional comparisons:          105
  Expression_Llvm_Type calls:       129

HARDCODED TYPE STRINGS:
-----------------------
  "ptr"    → 35 occurrences (should use LLVM_PTR_TYPE)
  "i1"     → 28 occurrences (should use LLVM_BOOL_TYPE)
  "i32"    → 20 occurrences (should derive from type system)
  "i64"    → 16 occurrences (should derive from type system)
  "double" → 17 occurrences (should use Float_Llvm_Type_Of)
  "float"  →  8 occurrences (should use Float_Llvm_Type_Of)
  "i8"     → 18 occurrences (should use LLVM_CHAR_TYPE)

================================================================================
                         FUNCTION QUALITY RATINGS
================================================================================

Each function rated 1-10:
  10 = Perfect, no changes needed
   8 = Good, minor improvements possible
   6 = Adequate, could be cleaner
   4 = Needs work, significant issues
   2 = Poor, major refactoring required
   0 = Disaster, rewrite completely

-------------------------------------------------------------------------------
INFRASTRUCTURE LAYER (Lines 17476-17600) - Average: 8.5/10
-------------------------------------------------------------------------------

[9/10] Temp_Set_Type (17476, 6 lines)
       Clean, focused, does one thing well.

[9/10] Temp_Get_Type (17484, 6 lines)
       Clean, hash collision check is smart.

[8/10] String_Bound_Type (17503, 3 lines)
       Good abstraction, could be macro.

[8/10] String_Bounds_Struct (17508, 3 lines)
       Good abstraction.

[8/10] Integer_Arith_Type (17520, 3 lines)
       Essential abstraction, widely used.

[9/10] Emit_Temp (17564, 3 lines)
       Perfect minimal function.

[9/10] Emit_Label (17568, 3 lines)
       Perfect minimal function.

[8/10] Emit (17572, 7 lines)
       Core emission, clean varargs.

[7/10] Emit_Label_Here (17580, 18 lines)
       Handles fallthrough, slightly complex logic.

[8/10] Emit_Float_Constant (17599, 28 lines)
       IEEE 754 hex emission, necessarily complex.

-------------------------------------------------------------------------------
SYMBOL & REFERENCE EMISSION (Lines 17769-18010) - Average: 7.0/10
-------------------------------------------------------------------------------

[6/10] Emit_Symbol_Name (17769, 80 lines)
       Too long. Name mangling should be separate from emission.
       FIX: Split into Mangle_Symbol_Name() + Emit_Mangled_Name().

[7/10] Emit_Symbol_Ref (17846, 6 lines)
       Clean wrapper.

[6/10] Emit_Exception_Ref (17853, 48 lines)
       Duplicates some logic from Emit_Symbol_Name.
       FIX: Consolidate exception naming.

[7/10] Emit_Symbol_Storage (17901, 54 lines)
       Complex but necessary for various symbol types.

[7/10] Emit_Nested_Frame_Arg (17955, 28 lines)
       Handles nested procedures, reasonable complexity.

[8/10] Emit_Raise_Exception (17983, 31 lines)
       Clean exception raising sequence.

-------------------------------------------------------------------------------
CONSTRAINT & OVERFLOW CHECKING (Lines 18014-18460) - Average: 6.5/10
-------------------------------------------------------------------------------

[7/10] Emit_Overflow_Checked_Op (18014, 59 lines)
       Good use of LLVM intrinsics. Well-structured.

[7/10] Emit_Division_Check (18073, 19 lines)
       Clean zero-check.

[6/10] Emit_Signed_Division_Overflow_Check (18092, 42 lines)
       Handles MIN_INT / -1 edge case. Could share more with Division_Check.

[6/10] Emit_Index_Check (18144, 35 lines)
       Duplicates bound extraction pattern.
       FIX: Use unified bound emission helper.

[5/10] Emit_Length_Check (18179, 22 lines)
       Similar pattern to Index_Check.
       FIX: Consolidate into single bounds-check abstraction.

[7/10] Emit_Access_Check (18201, 24 lines)
       Simple null check, clean.

[4/10] Emit_Discriminant_Check (18225, 240 lines)
       MASSIVE function. Handles all variant record checking.
       FIX: Split into helpers for each check type.

-------------------------------------------------------------------------------
TYPE CONVERSION & COERCION (Lines 18465-18600) - Average: 8.0/10
-------------------------------------------------------------------------------

[8/10] Emit_Convert_Ext (18465, 107 lines)
       Comprehensive but well-organized. Central conversion logic.
       MINOR: Could use lookup table for conversion operators.

[9/10] Emit_Convert (18570, 3 lines)
       Perfect wrapper for default signed conversion.

[8/10] Emit_Coerce (18579, 11 lines)
       Good abstraction combining Get_Type + Convert.

[8/10] Emit_Coerce_Default_Int (18590, 6 lines)
       Useful shortcut.

-------------------------------------------------------------------------------
BOUND & CONSTRAINT VALUE EMISSION (Lines 18608-18880) - Average: 6.0/10
-------------------------------------------------------------------------------

[6/10] Emit_Bound_Value_Typed (18608, 34 lines)
       Handles static vs dynamic bounds. Moderate duplication.
       FIX: Could be table-driven for bound kinds.

[7/10] Emit_Bound_Value (18642, 10 lines)
       Simple wrapper.

[4/10] Emit_Constraint_Check_With_Type (18652, 223 lines)
       MASSIVE. Handles all constraint checking.
       Major DRY violations - same patterns for each bound.
       FIX: Extract Check_Against_Bound() helper.

[7/10] Emit_Constraint_Check (18875, 8 lines)
       Clean wrapper.

-------------------------------------------------------------------------------
FAT POINTER OPERATIONS (Lines 18937-19490) - Average: 6.5/10
-------------------------------------------------------------------------------

[7/10] Emit_Fat_Pointer (18937, 34 lines)
       Clean fat pointer construction.

[8/10] Emit_Fat_Pointer_Data (19033, 11 lines)
       Simple extraction.

[8/10] Emit_Fat_Pointer_Bound (19044, 19 lines)
       Clean bounds pointer extraction.

[6/10] Emit_Fat_Pointer_Low (19063, 27 lines)
       Duplicates pattern from Emit_Fat_Pointer_High.
       FIX: Single Emit_Fat_Pointer_Bound_Value(is_low: bool) function.

[6/10] Emit_Fat_Pointer_High (19090, 27 lines)
       Same pattern as Low.
       FIX: Combine with Low.

[5/10] Emit_Fat_Pointer_Length (19117, 18 lines)
       Duplicates High-Low+1 pattern found elsewhere.
       FIX: Use shared length computation.

[6/10] Emit_Fat_Pointer_Length_Dim (19135, 43 lines)
       Multi-dimensional handling, reasonable complexity.

[5/10] Emit_Fat_Pointer_Dynamic (19178, 56 lines)
       Much duplication with Emit_Fat_Pointer.
       FIX: Consolidate into single parameterized function.

[7/10] Emit_Load_Fat_Pointer (19234, 80 lines)
       Complex but handles many symbol types correctly.

[6/10] Emit_Fat_Pointer_Compare (19314, 45 lines)
       Duplicates length/data extraction patterns.
       FIX: Use standard fat pointer accessors.

[7/10] Emit_Fat_Pointer_Null (19456, 18 lines)
       Clean null fat pointer construction.

-------------------------------------------------------------------------------
LVALUE GENERATION (Line 19491) - Average: 6.0/10
-------------------------------------------------------------------------------

[6/10] Generate_Lvalue (19491, 240 lines)
       Large function handling all lvalue cases.
       Moderate duplication in GEP patterns.
       FIX: Extract helpers for each lvalue kind.

-------------------------------------------------------------------------------
EXPRESSION GENERATION (Lines 19769-26473) - Average: 4.5/10
-------------------------------------------------------------------------------

[8/10] Generate_Integer_Literal (19769, 20 lines)
       Clean, simple.

[8/10] Generate_Real_Literal (19789, 13 lines)
       Clean, simple.

[7/10] Generate_String_Literal (19802, 27 lines)
       Reasonable complexity for string handling.

[5/10] Generate_Identifier (19829, 272 lines)
       Large function. Handles too many cases.
       FIX: Split by identifier kind (variable, literal, etc).

[6/10] Generate_Record_Equality (20105, 128 lines)
       Field-by-field comparison, moderate duplication.
       FIX: Use iterator pattern for fields.

[5/10] Generate_Array_Equality (20233, 104 lines)
       Duplicates length + memcmp patterns.
       FIX: Extract Compare_Array_Data() helper.

[5/10] Generate_Composite_Address (20337, 100 lines)
       Overlaps with Generate_Lvalue.
       FIX: Consolidate or clearly differentiate.

[2/10] Generate_Binary_Op (20636, 1354 lines) <<< WORST OFFENDER
       MASSIVE. Handles 20+ operator cases in one function.
       Extreme DRY violations - same patterns repeated per operator.
       Same left/right processing code repeated dozens of times.
       Same type conversion boilerplate everywhere.

       FIX: Complete rewrite needed:
       - Extract Generate_Arithmetic_Op()
       - Extract Generate_Comparison_Op()
       - Extract Generate_Logical_Op()
       - Extract Generate_Array_Op()
       - Use operator dispatch table
       - Factor out Operand_Pair structure with unified preprocessing

[6/10] Generate_Unary_Op (21990, 113 lines)
       Moderate size, handles all unary operators.
       Some duplication with Binary_Op patterns.

[5/10] Generate_Apply (23345, 460 lines)
       Large. Mixes array indexing with function calls.
       Intrinsic dispatch is a huge switch.
       FIX: Split array indexing from function calls.
       FIX: Move intrinsics to lookup table.

[5/10] Generate_Selected (23345, 248 lines)
       Record field selection + package qualification.
       FIX: Split into Generate_Field_Access and Generate_Qualified_Name.

[2/10] Generate_Attribute (23808, 1432 lines) <<< 2ND WORST OFFENDER
       MASSIVE. 40+ attribute types in single function.
       Each attribute is 30-100 lines of similar patterns.
       Runtime vs static bounds check repeated per attribute.

       FIX: Complete rewrite needed:
       - Create Attribute_Handler table
       - Extract Generate_Array_Attribute()
       - Extract Generate_Enum_Attribute()
       - Extract Generate_Scalar_Attribute()
       - Unified bounds access pattern

[4/10] Generate_Aggregate (25257, 856 lines)
       Large function handling all aggregate types.
       Bound generation duplicated for low/high.
       Element initialization loop duplicated per style.
       FIX: Split array vs record aggregates.
       FIX: Extract Emit_Bound_Value_Or_Expr() helper.

[6/10] Generate_Qualified (26113, 128 lines)
       Type qualification, moderate complexity.

[5/10] Generate_Allocator (26143, 330 lines)
       Dynamic allocation, some duplication with aggregate init.
       FIX: Share initialization code with aggregates.

[7/10] Generate_Expression (26473, 67 lines)
       Central dispatcher. Clean switch statement.

-------------------------------------------------------------------------------
STATEMENT GENERATION (Lines 26540-28800) - Average: 6.5/10
-------------------------------------------------------------------------------

[8/10] Generate_Statement_List (26542, 29 lines)
       Simple iteration, clean.

[6/10] Generate_Assignment (27181, 180 lines)
       Handles simple and slice assignments.
       Memcpy pattern duplicated with other places.

[7/10] Generate_If_Statement (27181, 46 lines)
       Clean conditional generation.

[6/10] Generate_Loop_Statement (27225, 49 lines)
       Basic while loop, clean.

[5/10] Generate_For_Loop (27610, 232 lines)
       Large, handles all iteration schemes.
       Range extraction duplicated from attributes.
       FIX: Use shared range extraction.

[6/10] Generate_Case_Statement (27438, 172 lines)
       Switch generation, moderate complexity.

[6/10] Generate_Return_Statement (27274, 164 lines)
       Return value + BIP handling.
       Some duplication with function epilogue.

[7/10] Generate_Raise_Statement (27846, 24 lines)
       Simple exception raise.

[6/10] Generate_Block_Statement (27870, 163 lines)
       Block with local declarations, reasonable.

[6/10] Generate_Statement (28033, 708 lines)
       Central dispatcher. Large switch but organized.

-------------------------------------------------------------------------------
DECLARATION & DEFINITION GENERATION (Lines 28817-31840) - Average: 5.5/10
-------------------------------------------------------------------------------

[7/10] Generate_Declaration_List (28811, 6 lines)
       Simple iteration.

[4/10] Generate_Object_Declaration (28817, 1032 lines) <<< 3RD WORST
       MASSIVE. Handles variables, constants, all initialization.
       Constraint initialization duplicated many times.
       Bound extraction duplicated.
       FIX: Split by declaration kind.
       FIX: Extract Init_Scalar(), Init_Array(), Init_Record().

[7/10] Emit_Extern_Subprogram (28773, 38 lines)
       Clean external declaration.

[6/10] Emit_Function_Header (29849, 100 lines)
       Function prologue with BIP params.
       Parameter list construction could be cleaner.

[5/10] Generate_Subprogram_Body (29917, 366 lines)
       Function body generation.
       Epilogue handling duplicated with generic instance.
       FIX: Extract Generate_Function_Epilogue().

[5/10] Generate_Generic_Instance_Body (30283, 261 lines)
       Generic instantiation body.
       Duplicates much of Generate_Subprogram_Body.
       FIX: Share code with Generate_Subprogram_Body.

[6/10] Generate_Task_Body (30567, 123 lines)
       Task type body generation.

[6/10] Generate_Declaration (30690, 727 lines)
       Central dispatcher. Large but organized.

[6/10] Generate_Type_Equality_Function (31417, 225 lines)
       Auto-generate composite equality.
       Field iteration similar to Generate_Record_Equality.

[7/10] Generate_Implicit_Operators (31642, 8 lines)
       Clean wrapper.

[6/10] Generate_Exception_Globals (31650, 92 lines)
       Exception identity globals.

[6/10] Generate_Extern_Declarations (31742, 98 lines)
       WITH'd package externs.

[7/10] Generate_Compilation_Unit (31840, 100 lines)
       Top-level entry point. Clean.

================================================================================
                         IDENTIFIED DRY VIOLATIONS
================================================================================

VIOLATION 1: BOUND EXTRACTION (Est. 600 lines recoverable)
----------------------------------------------------------
The pattern of extracting low/high bounds appears in 20+ locations:

  Pattern A - Static bounds:
    low_val = Emit_Temp(cg);
    Emit(cg, "  %%t%u = add %s 0, %s\n", low_val, bt, I128_Decimal(low));
    Temp_Set_Type(cg, low_val, bt);

  Pattern B - Dynamic bounds (BOUND_EXPR):
    low_val = Generate_Expression(cg, lb.expr);
    low_llvm = Expression_Llvm_Type(cg, lb.expr);
    if (strcmp(low_llvm, iat) != 0) low_val = Emit_Convert(...);

  Locations:
    - Generate_Binary_Op: 20696-20731, 20873-20897, 20918-20930
    - Generate_Attribute: 23871-23940, 23947-23970
    - Generate_Aggregate: 25334-25380
    - Generate_For_Loop: 27640-27700
    - Emit_Constraint_Check_With_Type: 18700-18800

  SOLUTION:
    typedef struct {
        uint32_t low_temp;
        uint32_t high_temp;
        const char *bound_type;
    } Bound_Temps;

    Bound_Temps Emit_Bounds(cg, Type_Info *type, uint32_t dim);
    Bound_Temps Emit_Bounds_From_Fat(cg, uint32_t fat_ptr, const char *bt);

VIOLATION 2: FAT POINTER NORMALIZATION (Est. 300 lines recoverable)
--------------------------------------------------------------------
The pattern of "wrap constrained array as fat pointer" appears 15+ times:

  Pattern:
    if (Expression_Produces_Fat_Pointer(...)) {
        val = Generate_Expression(cg, node);
    } else {
        ptr = Generate_Composite_Address(cg, node);
        lo = Type_Bound_Value(...);
        hi = Type_Bound_Value(...);
        val = Emit_Fat_Pointer(cg, ptr, lo, hi, bt);
    }

  SOLUTION:
    uint32_t Normalize_To_Fat_Pointer(cg, Syntax_Node *node, Type_Info *type);

VIOLATION 3: LENGTH COMPUTATION (Est. 200 lines recoverable)
-------------------------------------------------------------
The pattern "length = high - low + 1; clamp to 0 if null" appears 12+ times:

  Pattern:
    len = sub high, low
    len1 = add len, 1
    is_null = icmp sgt low, high
    result = select is_null, 0, len1

  SOLUTION:
    uint32_t Emit_Array_Length(cg, uint32_t low, uint32_t high, const char *bt);

VIOLATION 4: MEMCMP PATTERN (Est. 150 lines recoverable)
---------------------------------------------------------
The pattern for comparing array data with memcmp appears 8+ times:

  SOLUTION:
    uint32_t Emit_Memcmp(cg, uint32_t left, uint32_t right,
                         uint32_t len, uint32_t elem_size, const char *bt);

VIOLATION 5: REDUNDANT TYPE TRACKING (Est. 100 lines recoverable)
------------------------------------------------------------------
Emit_Convert_Ext already calls Temp_Set_Type at line 18565.
~100 additional Temp_Set_Type calls after Emit_Convert are REDUNDANT.

  SOLUTION: Remove all redundant Temp_Set_Type calls after Emit_Convert.

VIOLATION 6: BINARY OPERATOR PREPROCESSING (Est. 800 lines recoverable)
------------------------------------------------------------------------
Every binary operator case does similar operand setup.

  SOLUTION:
    typedef struct {
        uint32_t left, right;
        const char *left_type, *right_type;
        const char *result_type;
        bool is_float;
    } Binary_Operands;

    Binary_Operands Prepare_Binary_Operands(cg, Syntax_Node *node);

VIOLATION 7: CONDITIONAL BRANCH SEQUENCE (Est. 300 lines recoverable)
----------------------------------------------------------------------
The pattern for conditional check + raise appears 50+ times.

  SOLUTION:
    void Emit_Check_With_Raise(cg, uint32_t cond, const char *msg);

================================================================================
                         REFACTORING PHASES
================================================================================

PHASE 1: EXTRACT HELPER FUNCTIONS (Target: -1500 lines)
--------------------------------------------------------
[ ] 1.1 Create Bound_Temps + Emit_Bounds() family
[ ] 1.2 Create Emit_Array_Length()
[ ] 1.3 Create Normalize_To_Fat_Pointer()
[ ] 1.4 Create Emit_Memcmp() helper
[ ] 1.5 Create Emit_Check_With_Raise()
[ ] 1.6 Create Binary_Operands + Prepare_Binary_Operands()
[ ] 1.7 Remove redundant Temp_Set_Type calls

PHASE 2: SPLIT MONSTER FUNCTIONS (Target: -1000 lines)
-------------------------------------------------------
[ ] 2.1 Split Generate_Binary_Op (1354 -> ~600 lines)
        - Generate_Arithmetic_Op()
        - Generate_Comparison_Op()
        - Generate_Logical_Op()
        - Generate_Array_Binary_Op()
        - Generate_User_Defined_Op()

[ ] 2.2 Split Generate_Attribute (1432 -> ~700 lines)
        - Generate_Array_Attribute()
        - Generate_Enum_Attribute()
        - Generate_Scalar_Attribute()
        - Generate_Type_Attribute()

[ ] 2.3 Split Generate_Object_Declaration (1032 -> ~500 lines)
        - Generate_Scalar_Init()
        - Generate_Array_Init()
        - Generate_Record_Init()
        - Generate_Unconstrained_Init()

[ ] 2.4 Split Generate_Apply (460 -> ~280 lines)
        - Generate_Array_Index()
        - Generate_Function_Call()
        - Generate_Intrinsic()

PHASE 3: TABLE-DRIVEN OPERATIONS (Target: -500 lines)
------------------------------------------------------
[ ] 3.1 Intrinsic function table
[ ] 3.2 Arithmetic operator table
[ ] 3.3 Attribute handler table
[ ] 3.4 Type conversion table

PHASE 4: CONSOLIDATE DUPLICATE CODE (Target: -400 lines)
----------------------------------------------------------
[ ] 4.1 Merge Generate_Subprogram_Body + Generate_Generic_Instance_Body
[ ] 4.2 Merge Generate_Lvalue + Generate_Composite_Address
[ ] 4.3 Merge Emit_Fat_Pointer_Low + Emit_Fat_Pointer_High
[ ] 4.4 Merge Generate_Record_Equality + Generate_Type_Equality_Function
[ ] 4.5 Consolidate exception naming across functions

PHASE 5: ELIMINATE HARDCODED TYPES (Target: -50 lines)
-------------------------------------------------------
[ ] 5.1 Define type constants (LLVM_PTR_TYPE, LLVM_BOOL_TYPE, etc.)
[ ] 5.2 Replace all hardcoded "ptr" (35 occurrences)
[ ] 5.3 Replace all hardcoded "i1" (28 occurrences)
[ ] 5.4 Use Integer_Arith_Type(cg) instead of "i32"/"i64"
[ ] 5.5 Use Float_Llvm_Type_Of(type) instead of "float"/"double"

================================================================================
                         ESTIMATED RESULTS
================================================================================

CURRENT STATE:
  Code generation section: ~14,340 lines

AFTER REFACTORING:
  Phase 1: -1,500 lines (helper extraction)
  Phase 2: -1,000 lines (function splitting + dedup)
  Phase 3:   -500 lines (table-driven)
  Phase 4:   -400 lines (consolidation)
  Phase 5:    -50 lines (type constants)
  ---------------------------------
  Total:   -3,450 lines

FINAL STATE:
  Code generation section: ~10,890 lines (24% reduction)

QUALITY IMPROVEMENT:
  Average function rating: 5.8/10 -> 7.5/10
  Largest function: 1,432 lines -> ~200 lines
  DRY violations: ~20 major patterns -> 0

================================================================================
                         IMPLEMENTATION ORDER
================================================================================

WEEK 1 (Foundation):
  1.7 -> 1.1 -> 1.2 -> 1.3

WEEK 2-3 (Core Refactoring):
  2.1 -> 2.2 -> 2.3
  1.4 -> 1.5 -> 1.6

WEEK 4 (Table-Driven):
  3.1 -> 3.2 -> 3.3

WEEK 5 (Consolidation):
  4.1 -> 4.2 -> 4.3 -> 4.4 -> 4.5

WEEK 6 (Cleanup):
  5.1 -> 5.2 -> 5.3 -> 5.4 -> 5.5
  2.4 -> 3.4

================================================================================
                            RISK ASSESSMENT
================================================================================

LOW RISK:
  - Phase 1 (helper extraction) - purely additive
  - Phase 5 (type constants) - search-and-replace

MEDIUM RISK:
  - Phase 2 (function splitting) - must preserve all code paths
  - Phase 3 (table-driven) - must handle all edge cases

HIGH RISK:
  - Phase 4 (consolidation) - merging code paths is error-prone

MITIGATION:
  - Run all tests after each sub-phase
  - Use git bisect for regression hunting
  - Keep backup before each phase
  - Review for semantic equivalence

================================================================================
