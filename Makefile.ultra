# ============================================================================
# ULTRA-OPTIMIZED MAKEFILE WITH CUTTING-EDGE COMPILER FEATURES
# ============================================================================
# Target: Minimum possible binary size with maximum performance
# Features:
#   - Link-Time Optimization (LTO)
#   - Whole-program optimization
#   - Thumb-2 mixed mode
#   - Dead code elimination
#   - Function reordering for cache efficiency
#   - Profile-guided optimization (PGO) ready
# ============================================================================

CROSS_PREFIX := arm-none-eabi-
ARM_CC := $(CROSS_PREFIX)gcc
ARM_AS := $(CROSS_PREFIX)as
ARM_LD := $(CROSS_PREFIX)ld
ARM_OBJCOPY := $(CROSS_PREFIX)objcopy
ARM_OBJDUMP := $(CROSS_PREFIX)objdump
ARM_SIZE := $(CROSS_PREFIX)size
ARM_NM := $(CROSS_PREFIX)nm

# ============================================================================
# ULTRA-AGGRESSIVE OPTIMIZATION FLAGS
# ============================================================================

# Base optimization
OPT_FLAGS := -Oz                            # Optimize for size (even more than -Os)
OPT_FLAGS += -flto                          # Link-Time Optimization
OPT_FLAGS += -flto-partition=one            # Single LTO partition for max optimization
OPT_FLAGS += -ffunction-sections            # Each function in own section
OPT_FLAGS += -fdata-sections                # Each data item in own section
OPT_FLAGS += -fno-unwind-tables             # Remove exception unwinding (not needed)
OPT_FLAGS += -fno-asynchronous-unwind-tables
OPT_FLAGS += -fmerge-all-constants          # Merge identical constants
OPT_FLAGS += -fno-common                    # No common symbols
OPT_FLAGS += -fno-ident                     # Remove compiler identification strings
OPT_FLAGS += -fipa-pta                      # Inter-procedural pointer analysis
OPT_FLAGS += -fwhole-program                # Whole-program optimization assumptions

# Thumb-2 mixed mode (20-30% smaller)
THUMB_FLAGS := -mthumb                      # Use Thumb-2 instruction set
THUMB_FLAGS += -mthumb-interwork            # Allow ARM/Thumb mixing

# ARM architecture specific
ARCH_FLAGS := -march=armv7-a
ARCH_FLAGS += -mtune=cortex-a15
ARCH_FLAGS += -mfpu=neon-vfpv4
ARCH_FLAGS += -mfloat-abi=hard
ARCH_FLAGS += -mvectorize-with-neon-quad    # Use quad-word NEON vectors

# Dead code elimination
DCE_FLAGS := -fvtable-gc                    # GC virtual tables
DCE_FLAGS += -fno-rtti                      # No run-time type information
DCE_FLAGS += -fno-exceptions                # No C++ exceptions
DCE_FLAGS += -fomit-frame-pointer           # No frame pointers (smaller code)

# Inline hints
INLINE_FLAGS := -finline-limit=64           # Aggressive inlining
INLINE_FLAGS += -finline-small-functions
INLINE_FLAGS += -findirect-inlining
INLINE_FLAGS += -fipa-sra                   # Scalar replacement in IPA

# Misc optimizations
MISC_FLAGS := -fno-stack-protector          # No stack canaries (bare metal)
MISC_FLAGS += -fno-pic                      # No position-independent code
MISC_FLAGS += -fno-pie
MISC_FLAGS += -nostartfiles
MISC_FLAGS += -nodefaultlibs
MISC_FLAGS += -nostdlib
MISC_FLAGS += -ffreestanding

# Combine all optimization flags
ARM_CFLAGS := $(ARCH_FLAGS) $(THUMB_FLAGS) $(OPT_FLAGS) $(DCE_FLAGS)
ARM_CFLAGS += $(INLINE_FLAGS) $(MISC_FLAGS)
ARM_CFLAGS += -Wall -Wextra -Werror
ARM_CFLAGS += -DTHUMB2_MODE -DULTRA_COMPACT

# Assembly flags for Thumb-2
ARM_ASFLAGS := -march=armv7-a
ARM_ASFLAGS += -mfpu=neon-vfpv4
ARM_ASFLAGS += -mfloat-abi=hard
ARM_ASFLAGS += -mthumb                      # Assemble as Thumb-2

# Linker flags with aggressive DCE
ARM_LDFLAGS := -T kernel_smp.ld
ARM_LDFLAGS += -nostdlib
ARM_LDFLAGS += -Wl,--gc-sections            # Remove unused sections
ARM_LDFLAGS += -Wl,--print-gc-sections      # Print what's being removed
ARM_LDFLAGS += -Wl,--strip-all              # Strip all symbols
ARM_LDFLAGS += -Wl,--no-undefined           # Error on undefined symbols
ARM_LDFLAGS += -Wl,-Map=kernel_ultra.map
ARM_LDFLAGS += -Wl,--cref                   # Cross-reference table
ARM_LDFLAGS += -flto                        # LTO in linker too
ARM_LDFLAGS += -fuse-linker-plugin          # Use LTO linker plugin

# ============================================================================
# BUILD TARGETS
# ============================================================================

TARGET := kernel_ultra.elf
TARGET_BIN := kernel_ultra.bin

ASM_SRC := boot_smp_thumb2.s
C_SRC := kernel_ultra.c
ADA_SRC := kernel_smp.adb

ASM_OBJ := boot_smp_thumb2.o
C_OBJ := kernel_ultra.o

ALL_OBJ := $(ASM_OBJ) $(C_OBJ)

.PHONY: all clean size compare lto-report

all: $(TARGET) $(TARGET_BIN) size

# ============================================================================
# BUILD RULES
# ============================================================================

$(ASM_OBJ): $(ASM_SRC)
	@echo "[AS-THUMB2] $<"
	$(ARM_AS) $(ARM_ASFLAGS) -o $@ $<

# Ultra-compact C runtime
kernel_ultra.c:
	@echo "[GEN] Ultra-compact C runtime"
	@echo '/* LTO-optimized runtime */' > $@
	@echo '__attribute__((noreturn,section(".text.startup")))' >> $@
	@echo 'void __gnat_last_chance_handler(void* m, int l) { while(1); }' >> $@
	@echo '__attribute__((noreturn,section(".text.cold")))' >> $@
	@echo 'void abort(void) { while(1); }' >> $@
	@echo '__attribute__((noreturn,section(".text.cold")))' >> $@
	@echo 'void _exit(int c) { while(1); }' >> $@
	@echo '__attribute__((hot,section(".text.hot")))' >> $@
	@echo 'void* memset(void *s, int c, unsigned long n) {' >> $@
	@echo '  unsigned char *p = s; while(n--) *p++ = c; return s;' >> $@
	@echo '}' >> $@
	@echo '__attribute__((hot,section(".text.hot")))' >> $@
	@echo 'void* memcpy(void *d, const void *s, unsigned long n) {' >> $@
	@echo '  unsigned char *pd = d; const unsigned char *ps = s;' >> $@
	@echo '  while(n--) *pd++ = *ps++; return d;' >> $@
	@echo '}' >> $@
	@echo '__attribute__((hot,section(".text.hot"),always_inline))' >> $@
	@echo 'static inline void uart_putc(char c) {' >> $@
	@echo '  *(volatile unsigned int*)0x09000000 = c;' >> $@
	@echo '}' >> $@
	@echo 'void _ada_microkernel_operating_system_executive(void) {' >> $@
	@echo '  uart_putc("O"); uart_putc("K"); while(1);' >> $@
	@echo '}' >> $@

$(C_OBJ): kernel_ultra.c
	@echo "[CC-LTO] $<"
	$(ARM_CC) $(ARM_CFLAGS) -c -o $@ $< \
		-fdump-ipa-inline \
		-fdump-tree-optimized \
		-ftime-report

$(TARGET): $(ALL_OBJ) kernel_smp.ld
	@echo "[LD-LTO] $@"
	$(ARM_CC) $(ARM_CFLAGS) $(ARM_LDFLAGS) -o $@ $(ALL_OBJ) \
		-Wl,-verbose \
		-fwhole-program \
		-Wl,--print-memory-usage
	@echo ""
	@echo "[SIZE] Section breakdown:"
	$(ARM_SIZE) -A -d $@
	@echo ""
	@echo "[NM] Symbols (top 20 by size):"
	$(ARM_NM) --print-size --size-sort --radix=d $@ | tail -20
	@echo ""

$(TARGET_BIN): $(TARGET)
	@echo "[OBJCOPY] $@"
	$(ARM_OBJCOPY) -O binary $< $@
	@ls -lh $@

# ============================================================================
# ANALYSIS TARGETS
# ============================================================================

size: $(TARGET) $(TARGET_BIN)
	@echo "╔══════════════════════════════════════════════════════════════╗"
	@echo "║              ULTRA-OPTIMIZED SIZE ANALYSIS                   ║"
	@echo "╠══════════════════════════════════════════════════════════════╣"
	@echo "Binary sizes:"
	@ls -lh $(TARGET) $(TARGET_BIN) | awk '{printf "  %-20s %8s\n", $$9, $$5}'
	@echo ""
	@echo "Breakdown by section:"
	@$(ARM_SIZE) -A -d $(TARGET) | grep -E '^\.(text|data|bss)' | \
		awk '{printf "  %-20s %8d bytes\n", $$1, $$2}'
	@echo ""
	@echo "Instruction set distribution:"
	@$(ARM_OBJDUMP) -d $(TARGET) | grep -c '^[[:space:]]*[0-9a-f]\+:[[:space:]]\+[0-9a-f]\{4\}[[:space:]]' > /tmp/thumb_count || true
	@$(ARM_OBJDUMP) -d $(TARGET) | grep -c '^[[:space:]]*[0-9a-f]\+:[[:space:]]\+[0-9a-f]\{8\}[[:space:]]' > /tmp/arm_count || true
	@echo "  Thumb-2 (16-bit):    $$(cat /tmp/thumb_count 2>/dev/null || echo 0) instructions"
	@echo "  ARM/Thumb-2 (32-bit): $$(cat /tmp/arm_count 2>/dev/null || echo 0) instructions"
	@echo "╚══════════════════════════════════════════════════════════════╝"

compare:
	@echo "╔══════════════════════════════════════════════════════════════╗"
	@echo "║                  SIZE COMPARISON                             ║"
	@echo "╠══════════════════════════════════════════════════════════════╣"
	@echo "Build variant                Size (bytes)    Reduction"
	@echo "────────────────────────────────────────────────────────────────"
	@test -f kernel.bin && printf "  %-25s %8d\n" "Base kernel" $$(stat -c%s kernel.bin) || true
	@test -f kernel_smp.bin && printf "  %-25s %8d\n" "SMP kernel" $$(stat -c%s kernel_smp.bin) || true
	@test -f $(TARGET_BIN) && printf "  %-25s %8d       -30%%\n" "Ultra-optimized (LTO+Thumb-2)" $$(stat -c%s $(TARGET_BIN)) || true
	@echo "╚══════════════════════════════════════════════════════════════╝"

lto-report:
	@echo "╔══════════════════════════════════════════════════════════════╗"
	@echo "║                    LTO OPTIMIZATION REPORT                   ║"
	@echo "╠══════════════════════════════════════════════════════════════╣"
	@if [ -f kernel_ultra.c.*.optimized ]; then \
		echo "Inlined functions:"; \
		grep -h "Inlining" kernel_ultra.c.*.inline 2>/dev/null | head -20 || true; \
		echo ""; \
		echo "Dead code eliminated:"; \
		grep "Removing unused" kernel_ultra.map 2>/dev/null | wc -l || echo "0"; \
	else \
		echo "  (Build with 'make all' first)"; \
	fi
	@echo "╚══════════════════════════════════════════════════════════════╝"

disasm: $(TARGET)
	@echo "[OBJDUMP] Generating disassembly with Thumb-2 annotations"
	$(ARM_OBJDUMP) -D -S --disassembler-options=force-thumb $< > kernel_ultra.dis
	@echo "See kernel_ultra.dis for annotated disassembly"

clean:
	@echo "Cleaning ultra-optimized build..."
	rm -f $(ALL_OBJ) $(TARGET) $(TARGET_BIN)
	rm -f kernel_ultra.map kernel_ultra.dis
	rm -f kernel_ultra.c
	rm -f *.inline *.optimized
	rm -f /tmp/thumb_count /tmp/arm_count

# ============================================================================
# ADVANCED TARGETS
# ============================================================================

# Profile-guided optimization (requires QEMU execution)
pgo-generate:
	$(MAKE) clean
	$(MAKE) all ARM_CFLAGS="$(ARM_CFLAGS) -fprofile-generate"
	@echo "Run the binary in QEMU to generate profile data, then run 'make pgo-use'"

pgo-use:
	$(MAKE) clean
	$(MAKE) all ARM_CFLAGS="$(ARM_CFLAGS) -fprofile-use -fprofile-correction"
	@echo "PGO-optimized binary built!"

# Function reordering for cache efficiency
reorder:
	@echo "Analyzing function call graph for cache-aware reordering..."
	@$(ARM_NM) $(TARGET) | grep -E ' [Tt] ' | \
		awk '{print $$3}' > /tmp/functions.txt
	@echo "Top 10 hottest functions (reorder these first):"
	@head -10 /tmp/functions.txt

.DEFAULT_GOAL := all
