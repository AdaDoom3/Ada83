PRAGMA IMPLEMENTATION ANALYSIS FOR ADA83 COMPILER
=================================================

1. THEORETICAL FOUNDATIONS

   A pragma (from Greek πρᾶγμα, "thing done") is a compiler directive that
   modifies compilation behavior without altering program semantics. Per
   LRM Section 2.8, pragmas affect compilation but do not change the
   meaning of a legal program.

   Formal Definition: Let P be a program and π be a pragma. Then:
      Semantics(P) = Semantics(P ∪ {π})

   However, compilation behavior may differ:
      Compile(P, π) ≠ Compile(P, ∅)


2. REQUIRED PRAGMAS (LRM ANNEX B)

   The Ada83 standard mandates support for exactly 14 pragmas:

   2.1 COMPILATION-UNIT LEVEL PRAGMAS
       MEMORY_SIZE(numeric_literal)        - Before first compilation unit
       STORAGE_UNIT(numeric_literal)       - Before first compilation unit
       SYSTEM_NAME(enumeration_literal)    - Before first compilation unit
       ELABORATE(library_unit_names...)    - After context clause

   2.2 DECLARATIVE PRAGMAS
       CONTROLLED(access_type_name)        - In declarative region
       INLINE(subprogram_names...)         - In declarative region
       INTERFACE(language, subprogram)     - In declarative region
       PACK(type_name)                     - As representation clause
       PRIORITY(static_expression)         - In task spec or main
       SHARED(variable_name)               - After variable declaration
       SUPPRESS(check_name [, entity])     - In declarative region

   2.3 LIST CONTROL PRAGMAS
       LIST(ON | OFF)                      - Anywhere pragma allowed
       OPTIMIZE(TIME | SPACE)              - In declarative part
       PAGE                                - Anywhere pragma allowed


3. GNAT PRAGMA IMPLEMENTATION PATTERNS

   Analysis of reference/gnat/*.ad[sb] reveals four implementation patterns:

   3.1 PARSE-TIME ELIMINATION
       Pragmas LIST and PAGE have no semantic effect on generated code.
       GNAT: Consume during lexical analysis, emit to listing generator.

   3.2 SEMANTIC ANNOTATION
       Pragmas INLINE, OPTIMIZE, PACK annotate symbol table entries.
       GNAT: Attach pragma flags to Sy* during rdl() semantic analysis.
       Example: s->inl = true for INLINE pragma on subprogram s.

   3.3 COMPILATION ENVIRONMENT MODIFICATION
       Pragmas MEMORY_SIZE, STORAGE_UNIT, SYSTEM_NAME affect predefined
       constants. GNAT: Modify system.ads constants during smi().

   3.4 CODE GENERATION TRANSFORMATION
       Pragmas SUPPRESS, CONTROLLED affect emitted LLVM IR.
       GNAT: Check pragma flags during gex(), omit checks or add GC calls.


4. CURRENT IMPLEMENTATION STATUS (ada83.c)

   4.1 LEXER (ln function, line 24)
       T_PGM token exists but no keyword differentiation.
       All pragmas lexed identically as "pragma <identifier>".

   4.2 PARSER (prc function, line 97)
       Limited recognition in representation clause context:
          if (pm(p,T_PGM)) {
             S nm=pi(p);
             if (si(nm,Z("ELABORATE"))||si(nm,Z("ELABORATE_ALL"))||
                 si(nm,Z("PACK"))) {
                /* Parse arguments and discard */
             }
          }

       Analysis: Parser recognizes syntax but performs no semantic actions.
       Pragmas are consumed and discarded. No symbol table annotation occurs.

   4.3 SEMANTIC ANALYZER (rdl/rss functions)
       No pragma processing. Symbol table Sy struct lacks pragma flags.

   4.4 CODE GENERATOR (gex/gss functions)
       No pragma-conditional code emission.


5. DYNAMIC SEMANTICS CONSIDERATIONS

   Per LRM 11.7, pragma SUPPRESS has runtime implications:

      "The permission to omit the given check extends from the place of
       the pragma to the end of the declarative region..."

   This requires scope-aware check suppression. Consider:

      procedure P is
         type T is range 1..100;
         pragma SUPPRESS(RANGE_CHECK, T);
         X : T;
      begin
         X := 200;  -- Check suppressed, undefined behavior allowed
      end P;

   Implementation requires:
      (a) Symbol table annotation: T->suppress_range = true
      (b) Code gen modification: In gex N_CHK case, query type flags
      (c) Scope management: Clear flags at scope exit (sco function)

   Similarly, pragma CONTROLLED affects garbage collection timing:

      type Ptr is access Integer;
      pragma CONTROLLED(Ptr);

   This suppresses automatic collection until block exit. Requires:
      (a) Type annotation: Ptr->controlled = true
      (b) GC suppression: Skip __ada_gc_collect calls in gex
      (c) Explicit collection: Emit collection call at scope exit


6. IMPLEMENTATION STRATEGY

   Phase I - Symbol Table Extensions
      Add pragma flags to Ty and Sy structures:
         struct Sy {
            ...
            bool inl;     // INLINE pragma applied
            bool shrd;    // SHARED pragma applied
         };

         struct Ty {
            ...
            bool pk;      // PACK pragma applied (already exists)
            bool ctrl;    // CONTROLLED pragma applied
            uint16_t sup; // Bitmask of suppressed checks
         };

   Phase II - Parsing Enhancement
      Extend prc() to handle all pragma forms:
         - Recognize pragma names via string comparison
         - Parse argument lists per pragma syntax rules
         - Return pragma descriptor structure

      Add pdl() pragma processing:
         - Call prc() when T_PGM encountered
         - Annotate relevant symbol table entries
         - Store pragma effects in semantic environment

   Phase III - Semantic Actions
      Implement pragma-specific handlers in rdl():
         - INLINE: Mark subprogram for inlining
         - PACK: Set type packing flag
         - SUPPRESS: Set check suppression mask
         - CONTROLLED: Set GC control flag
         - SHARED: Set synchronization flag

   Phase IV - Code Generation
      Modify gex() check emission:
         if (t && t->sup & CHK_RANGE) {
            /* Omit range check code */
         } else {
            /* Emit normal check */
         }

      Modify gdl() for INLINE:
         if (s->inl) {
            /* Emit linkonce_odr with inline attribute */
         }


7. COMPATIBILITY WITH EXISTING ARCHITECTURE

   The ultra-compressed single-line style presents challenges. Current code:

      static void rex(Sm*SM,No*n,Ty*tx){if(!n)return;switch(n->k){case N_ID:...

   Adding pragma checks requires minimal branch expansion. Strategy:
      - Add pragma flags to existing structures (Sy, Ty)
      - Check flags inline during code generation
      - Use ternary operators to maintain line compression

   Example transformation for SUPPRESS:

      Before:
         if (t->k==TY_I && (t->lo!=TY_INT->lo || t->hi!=TY_INT->hi)) {
            /* Emit range check */
         }

      After:
         if (t->k==TY_I && (t->lo!=TY_INT->lo || t->hi!=TY_INT->hi) &&
             !(t->sup&CHK_RANGE)) {
            /* Emit range check */
         }


8. ACATS TEST COVERAGE

   Pragma testing appears in multiple ACATS test categories:

      B2A* - Pragma syntax and placement tests
      C3A* - Pragma PACK with record types
      C6*  - Pragma INLINE with subprograms
      C9*  - Pragma PRIORITY with tasks
      C11* - Pragma SUPPRESS with checks
      L3*  - Pragma LIST and PAGE with listings

   Initial implementation should target SUPPRESS (check elimination) and
   INLINE (code expansion) as these have observable runtime effects.


9. REFERENCES

   [1] Ada 83 LRM, Section 2.8 - Pragmas
   [2] Ada 83 LRM, Annex B - Predefined Language Pragmas
   [3] Ada 83 LRM, Section 11.7 - Suppressing Checks
   [4] GNAT sources, reference/gnat/*.ad[sb]
   [5] Current ada83.c implementation


APPENDIX A - CHECK SUPPRESSION BITMASK ENCODING

   Define suppression flags as powers of 2 for efficient bitmasking:

      #define CHK_OVERFLOW       (1 << 0)  // Overflow in numeric ops
      #define CHK_RANGE          (1 << 1)  // Range constraint violation
      #define CHK_INDEX          (1 << 2)  // Array index out of bounds
      #define CHK_DISCRIMINANT   (1 << 3)  // Discriminant check
      #define CHK_LENGTH         (1 << 4)  // Array length match
      #define CHK_DIVISION       (1 << 5)  // Division by zero
      #define CHK_ELABORATION    (1 << 6)  // Elaboration order
      #define CHK_ACCESS         (1 << 7)  // Null pointer dereference
      #define CHK_STORAGE        (1 << 8)  // Storage allocation failure

   Usage in type structure:
      t->sup |= CHK_RANGE;  // Suppress range checks
      if (t->sup & CHK_RANGE) { /* check suppressed */ }
